---
phase: 13-event-hooks
plan: 03
type: execute
wave: 3
depends_on: ["13-02"]
files_modified:
  - src/app/state.rs
  - src/ui/mod.rs
  - src/app/event.rs
  - src/plugin/loader.rs
autonomous: true

must_haves:
  truths:
    - "AppState has HookDispatcher and in_hook_apply flag for cascade prevention"
    - "apply_pending_hook_results() polls hook results and applies commands without undo (intentional - hooks are secondary effects)"
    - "Events are fired from todo mutations (toggle state, add item, delete item, modify content)"
    - "Hook-triggered modifications do NOT fire new events (cascade prevention)"
    - "Hook errors display in plugin error popup (reuse existing infrastructure)"
    - "OnLoad event fires after todo list load on startup"
  artifacts:
    - path: "src/app/state.rs"
      provides: "Hook integration with AppState"
      contains: "apply_pending_hook_results"
    - path: "src/ui/mod.rs"
      provides: "Hook polling in event loop"
      contains: "apply_pending_hook_results"
  key_links:
    - from: "src/app/state.rs"
      to: "src/plugin/hooks.rs"
      via: "HookDispatcher owned by AppState"
      pattern: "hook_dispatcher"
    - from: "src/ui/mod.rs"
      to: "src/app/state.rs"
      via: "apply_pending_hook_results() call in event loop"
      pattern: "apply_pending_hook_results"
---

<objective>
Integrate hook dispatcher with TUI: fire events from mutations, poll results in event loop, apply commands.

Purpose: Complete hook system - enables plugins to react to todo lifecycle events asynchronously.
Output: Working event hooks with cascade prevention and error handling.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-event-hooks/13-RESEARCH.md
@.planning/phases/13-event-hooks/13-02-PLAN.md
@src/app/state.rs
@src/ui/mod.rs
@src/app/event.rs
@src/plugin/command_executor.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add HookDispatcher and cascade flag to AppState</name>
  <files>src/app/state.rs</files>
  <action>
    1. Add imports:
       ```rust
       use crate::plugin::hooks::HookDispatcher;
       use totui_plugin_interface::{FfiEvent, FfiEventSource, FfiFieldChange, FfiEventType};
       ```

    2. Add fields to AppState struct:
       ```rust
       /// Hook dispatcher for async event handling.
       pub hook_dispatcher: HookDispatcher,

       /// True when applying hook-returned commands (prevents cascade).
       in_hook_apply: bool,
       ```

    3. Initialize in AppState::new():
       ```rust
       hook_dispatcher: HookDispatcher::new(),
       in_hook_apply: false,
       ```

    4. Add method to fire events:
       ```rust
       /// Fire an event to all subscribed plugins.
       ///
       /// Does nothing if currently applying hook results (cascade prevention).
       pub fn fire_event(&self, event: FfiEvent) {
           if self.in_hook_apply {
               return; // Prevent cascade
           }

           let event_type = event.event_type();
           let subscribed = self.plugin_loader.plugins_for_event(event_type);

           for (plugin, timeout) in subscribed {
               self.hook_dispatcher.dispatch_to_plugin(event.clone(), plugin, timeout);
           }
       }
       ```

    5. Add method to apply pending hook results:
       ```rust
       /// Poll hook results and apply commands.
       ///
       /// Called from UI event loop each frame.
       /// Commands are applied without undo (hooks are secondary effects).
       pub fn apply_pending_hook_results(&mut self) {
           let results = self.hook_dispatcher.poll_results();

           for result in results {
               // Handle errors
               if let Some(error) = result.error {
                   self.pending_plugin_errors.push(crate::plugin::loader::PluginLoadError {
                       plugin_name: result.plugin_name.clone(),
                       error_kind: crate::plugin::loader::PluginErrorKind::Panicked {
                           message: error.clone(),
                       },
                       message: format!("Hook failed: {}", error),
                   });
                   self.show_plugin_error_popup = true;
                   continue;
               }

               if result.commands.is_empty() {
                   continue;
               }

               // Apply commands WITHOUT undo snapshot (intentional design decision).
               // Hook modifications are secondary effects, not user-initiated actions.
               // If user undoes the original action, hook effects would become orphaned.
               // This is consistent with Phase 9's CommandExecutor which provides the
               // execute_batch() method - undo snapshot is caller's responsibility.
               // For hooks, we deliberately skip the snapshot.
               self.in_hook_apply = true;

               let mut executor = crate::plugin::command_executor::CommandExecutor::new(
                   result.plugin_name.clone(),
               );

               match executor.execute_batch(&result.commands, &mut self.todo_list, &self.project_name) {
                   Ok(_) => {
                       self.unsaved_changes = true;
                       tracing::debug!(
                           plugin = %result.plugin_name,
                           commands = result.commands.len(),
                           "Applied hook commands"
                       );
                   }
                   Err(e) => {
                       tracing::warn!(
                           plugin = %result.plugin_name,
                           error = %e,
                           "Hook command execution failed"
                       );
                   }
               }

               self.in_hook_apply = false;
           }
       }
       ```

    Note: The fire_event method takes &self because HookDispatcher uses interior mutability
    (mpsc channel sender can be cloned). If needed, change to take &self and use RefCell
    or change plugin_loader to be accessed via method.
  </action>
  <verify>cargo check</verify>
  <done>AppState has HookDispatcher, fire_event(), and apply_pending_hook_results()</done>
</task>

<task type="auto">
  <name>Task 2: Add hook polling to UI event loop</name>
  <files>src/ui/mod.rs</files>
  <action>
    In run_app() function, add hook polling after existing checks:

    ```rust
    fn run_app(
        terminal: &mut Terminal<CrosstermBackend<io::Stdout>>,
        state: &mut AppState,
        db_rx: mpsc::Receiver<()>,
    ) -> Result<()> {
        loop {
            state.clear_expired_status_message();
            state.check_plugin_result();
            state.check_version_update();
            state.tick_spinner();
            state.check_download_progress();

            // Poll and apply hook results
            state.apply_pending_hook_results();

            terminal.draw(|f| {
                components::render(f, state);
            })?;

            // ... rest of loop unchanged
        }
    }
    ```

    This ensures hook results are processed each frame before rendering.
  </action>
  <verify>cargo check</verify>
  <done>UI event loop polls hook results each frame</done>
</task>

<task type="auto">
  <name>Task 3a: Document mutation sites for event firing</name>
  <files>No files modified - research task</files>
  <action>
    Research and document all mutation sites that need event firing.

    Using grep, locate the following mutation patterns in src/app/state.rs and src/app/event.rs:

    1. **State toggle**: Search for `toggle_current_item_state` and `cycle_current_item_state`
       - Expected location: src/app/state.rs
       - Pattern: Methods that call `save_undo()` then modify `item.state`

    2. **Add item**: Search for `TodoItem::new` or `items.push` or `items.insert`
       - Expected location: src/app/event.rs (handle_key_event for 'o'/'O')
       - Pattern: Creating new item and inserting into list

    3. **Delete item**: Search for `deleted_at` or methods named `delete`
       - Expected location: src/app/state.rs or event.rs
       - Pattern: Setting deleted_at timestamp (soft delete)

    4. **Content edit**: Search for where `item.content =` is assigned
       - Expected location: src/app/event.rs (after edit mode completion)
       - Pattern: Exiting insert mode and committing content change

    Record findings as comments at the top of src/app/state.rs:
    ```rust
    // EVENT FIRING SITES (Phase 13):
    // - toggle_current_item_state() at line XXX -> OnComplete/OnModify(State)
    // - cycle_current_item_state() at line XXX -> OnModify(State)
    // - [event.rs] handle_key_event 'o'/'O' at line XXX -> OnAdd
    // - [location] delete method at line XXX -> OnDelete
    // - [event.rs] handle_insert_mode exit at line XXX -> OnModify(Content)
    ```
  </action>
  <verify>grep -n "save_undo\|toggle_current_item_state\|cycle_current_item_state\|deleted_at" src/app/state.rs</verify>
  <done>All mutation sites documented with file paths and line numbers</done>
</task>

<task type="auto">
  <name>Task 3b: Add event firing to mutation sites</name>
  <files>src/app/state.rs, src/app/event.rs</files>
  <action>
    Using the mutation sites documented in Task 3a, add event firing.
    The strategy is to fire events AFTER the mutation is complete (post-facto).

    1. In AppState, add helper to convert TodoItem to FfiTodoItem:
       ```rust
       fn todo_to_ffi(&self, index: usize) -> Option<totui_plugin_interface::FfiTodoItem> {
           self.todo_list.items.get(index).map(|item| item.into())
       }
       ```

    2. Fire OnComplete/OnModify on state toggle:
       At the END of toggle_current_item_state() (after the state change):
       ```rust
       // Fire event for state change
       if let Some(ffi_item) = self.todo_to_ffi(self.cursor_position) {
           let event = if self.todo_list.items[self.cursor_position].state.is_checked() {
               FfiEvent::OnComplete { todo: ffi_item }
           } else {
               FfiEvent::OnModify {
                   todo: ffi_item,
                   field_changed: FfiFieldChange::State,
               }
           };
           self.fire_event(event);
       }
       ```

    3. Fire OnAdd when a new todo is created:
       At the site identified in Task 3a, after the item is added:
       ```rust
       if let Some(ffi_item) = state.todo_to_ffi(new_item_index) {
           let event = FfiEvent::OnAdd {
               todo: ffi_item,
               source: FfiEventSource::Manual,
           };
           state.fire_event(event);
       }
       ```

    4. Fire OnDelete when a todo is soft-deleted:
       BEFORE the deletion (to capture item data):
       ```rust
       if let Some(item) = state.todo_list.items.get(delete_index) {
           let ffi_item: totui_plugin_interface::FfiTodoItem = item.into();
           let event = FfiEvent::OnDelete { todo: ffi_item };
           state.fire_event(event);
       }
       ```

    5. Fire OnModify for content changes:
       At the site identified in Task 3a:
       ```rust
       if let Some(ffi_item) = state.todo_to_ffi(edited_index) {
           let event = FfiEvent::OnModify {
               todo: ffi_item,
               field_changed: FfiFieldChange::Content,
           };
           state.fire_event(event);
       }
       ```

    Focus on the 4 main mutation paths: toggle state, add item, delete item, edit content.
    Other changes (due date, priority, etc.) can be added in a follow-up if needed.
  </action>
  <verify>cargo check && cargo test</verify>
  <done>Events fire from state toggle, add item, delete item, and content edit</done>
</task>

<task type="auto">
  <name>Task 4: Fire OnLoad event at startup</name>
  <files>src/app/state.rs</files>
  <action>
    Add method to fire OnLoad event and call it during AppState initialization:

    1. Add method:
       ```rust
       /// Fire OnLoad event to subscribed plugins.
       ///
       /// Called once after todo list is loaded, before first render.
       pub fn fire_on_load_event(&self) {
           let event = FfiEvent::OnLoad {
               project_name: self.project_name.clone().into(),
               date: self.todo_list.date.format("%Y-%m-%d").to_string().into(),
           };
           self.fire_event(event);
       }
       ```

    2. Call at the end of AppState::new() (after todo list is loaded):
       ```rust
       // Fire OnLoad event for plugins
       state.fire_on_load_event();

       state // or Ok(state) depending on return type
       ```

    This fires before the first render but after all state is initialized.
  </action>
  <verify>cargo check && cargo test</verify>
  <done>OnLoad event fires at startup after todo list load</done>
</task>

</tasks>

<verification>
1. Run `cargo check` - no errors
2. Run `cargo test` - all tests pass
3. Run `cargo clippy` - no warnings
4. Manual test: Start TUI, toggle a todo - no crash (hooks fire but no plugins subscribed)
5. Verify cascade prevention: in_hook_apply flag prevents recursive events
</verification>

<success_criteria>
- HookDispatcher owned by AppState
- fire_event() dispatches to subscribed plugins
- apply_pending_hook_results() in UI loop
- in_hook_apply flag prevents cascade
- Mutation sites documented with file paths and line numbers (Task 3a)
- OnAdd, OnModify, OnComplete, OnDelete events fire from mutations (Task 3b)
- OnLoad event fires at startup
- Hook errors show in plugin error popup
- Commands applied without undo (intentional - hooks are secondary effects)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-event-hooks/13-03-SUMMARY.md`
</output>
