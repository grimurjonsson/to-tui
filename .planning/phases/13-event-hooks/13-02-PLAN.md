---
phase: 13-event-hooks
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/plugin/hooks.rs
  - src/plugin/mod.rs
  - src/plugin/loader.rs
  - src/plugin/manifest.rs
autonomous: true

must_haves:
  truths:
    - "HookDispatcher dispatches events to subscribed plugins in background threads"
    - "Hook results are returned via mpsc channel for UI thread polling"
    - "Consecutive failures auto-disable plugin hooks (threshold: 3)"
    - "Hook timeout is configurable per plugin in manifest (default: 5 seconds)"
    - "PluginLoader tracks which plugins subscribe to which events"
  artifacts:
    - path: "src/plugin/hooks.rs"
      provides: "HookDispatcher with async event dispatch and result polling"
      exports: ["HookDispatcher", "HookResult"]
    - path: "src/plugin/manifest.rs"
      provides: "Extended manifest with hook_timeout_secs field"
      contains: "hook_timeout_secs"
  key_links:
    - from: "src/plugin/hooks.rs"
      to: "src/plugin/loader.rs"
      via: "PluginLoader reference for plugin access"
      pattern: "PluginLoader"
---

<objective>
Create HookDispatcher for async event dispatch with timeout, failure tracking, and result collection.

Purpose: Core hook execution infrastructure - enables non-blocking plugin hooks with safety guarantees.
Output: hooks.rs module with HookDispatcher, HookResult, and manifest extension for timeout.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-event-hooks/13-RESEARCH.md
@.planning/phases/13-event-hooks/13-01-PLAN.md
@src/plugin/loader.rs
@src/plugin/manifest.rs
@src/utils/version_check.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add hook_timeout_secs to manifest</name>
  <files>src/plugin/manifest.rs</files>
  <action>
    Add hook timeout field to PluginManifest struct:

    ```rust
    /// Timeout for hook execution in seconds (default: 5).
    /// Hooks that exceed this timeout will be terminated and counted as failures.
    #[serde(default = "default_hook_timeout")]
    pub hook_timeout_secs: u64,
    ```

    Add default function:
    ```rust
    fn default_hook_timeout() -> u64 {
        5
    }
    ```

    Update the test to include the new field in test manifests or verify it uses default.
  </action>
  <verify>cargo test -p totui manifest -- --nocapture</verify>
  <done>PluginManifest has hook_timeout_secs field with default of 5</done>
</task>

<task type="auto">
  <name>Task 2: Create hooks.rs with HookDispatcher</name>
  <files>src/plugin/hooks.rs, src/plugin/mod.rs</files>
  <action>
    Create new module `src/plugin/hooks.rs`:

    ```rust
    //! Hook dispatcher for async plugin event handling.
    //!
    //! Dispatches todo lifecycle events to subscribed plugins in background threads,
    //! collecting results via channels for UI thread polling.

    use std::collections::{HashMap, HashSet};
    use std::sync::mpsc;
    use std::thread;
    use std::time::Duration;

    use totui_plugin_interface::{
        call_plugin_on_event, FfiCommand, FfiEvent, FfiEventType, FfiHookResponse,
    };

    use crate::plugin::loader::LoadedPlugin;

    /// Default timeout for hooks (5 seconds).
    pub const DEFAULT_HOOK_TIMEOUT: Duration = Duration::from_secs(5);

    /// Auto-disable threshold (3 consecutive failures).
    pub const AUTO_DISABLE_THRESHOLD: u32 = 3;

    /// Result of a hook execution.
    #[derive(Debug)]
    pub struct HookResult {
        /// Name of the plugin that executed the hook.
        pub plugin_name: String,
        /// Type of event that was handled.
        pub event_type: FfiEventType,
        /// Commands to apply (empty if hook returned no modifications).
        pub commands: Vec<FfiCommand>,
        /// Error message if hook failed (timeout, panic, or plugin error).
        pub error: Option<String>,
    }

    /// Dispatches events to subscribed plugins asynchronously.
    ///
    /// Events are dispatched in background threads, with results collected
    /// via a channel that the UI thread polls each frame.
    pub struct HookDispatcher {
        /// Channel to receive completed hook results.
        result_rx: mpsc::Receiver<HookResult>,
        /// Sender cloned for each hook thread.
        result_tx: mpsc::Sender<HookResult>,
        /// Consecutive failure count per plugin (for auto-disable).
        failure_counts: HashMap<String, u32>,
        /// Session-disabled plugin hooks (from failures).
        disabled_hooks: HashSet<String>,
    }

    impl Default for HookDispatcher {
        fn default() -> Self {
            Self::new()
        }
    }

    impl HookDispatcher {
        /// Create a new hook dispatcher.
        pub fn new() -> Self {
            let (result_tx, result_rx) = mpsc::channel();
            Self {
                result_rx,
                result_tx,
                failure_counts: HashMap::new(),
                disabled_hooks: HashSet::new(),
            }
        }

        /// Check if a plugin's hooks are disabled.
        pub fn is_hook_disabled(&self, plugin_name: &str) -> bool {
            self.disabled_hooks.contains(plugin_name)
        }

        /// Dispatch an event to a single plugin.
        ///
        /// Non-blocking - hook runs in background thread.
        /// Result will be available via `poll_results()`.
        ///
        /// # Arguments
        /// * `event` - The event to dispatch
        /// * `plugin` - The loaded plugin to call
        /// * `timeout` - Timeout for this hook call
        pub fn dispatch_to_plugin(
            &self,
            event: FfiEvent,
            plugin: &LoadedPlugin,
            timeout: Duration,
        ) {
            // Skip if hook is disabled for this plugin
            if self.disabled_hooks.contains(&plugin.name) {
                return;
            }

            let tx = self.result_tx.clone();
            let plugin_name = plugin.name.clone();
            let event_type = event.event_type();

            // Clone the plugin reference for the thread.
            // This is safe because Plugin_TO is 'static (library never unloads).
            let plugin_ref = plugin.plugin.clone();

            thread::spawn(move || {
                let result = call_hook_with_timeout(&plugin_ref, event, timeout);

                let hook_result = match result {
                    Ok(response) => HookResult {
                        plugin_name,
                        event_type,
                        commands: response.commands.into_iter().collect(),
                        error: None,
                    },
                    Err(e) => HookResult {
                        plugin_name,
                        event_type,
                        commands: vec![],
                        error: Some(e),
                    },
                };

                // Send result (ignore error if receiver dropped)
                let _ = tx.send(hook_result);
            });
        }

        /// Poll for completed hook results (non-blocking).
        ///
        /// Call this from the UI event loop to receive hook results.
        /// Updates failure tracking and auto-disables hooks after threshold.
        pub fn poll_results(&mut self) -> Vec<HookResult> {
            let mut results = Vec::new();

            while let Ok(result) = self.result_rx.try_recv() {
                // Track failures for auto-disable
                if result.error.is_some() {
                    let count = self.failure_counts
                        .entry(result.plugin_name.clone())
                        .or_insert(0);
                    *count += 1;

                    if *count >= AUTO_DISABLE_THRESHOLD {
                        self.disabled_hooks.insert(result.plugin_name.clone());
                        tracing::warn!(
                            plugin = %result.plugin_name,
                            "Plugin hooks auto-disabled after {} consecutive failures",
                            AUTO_DISABLE_THRESHOLD
                        );
                    }
                } else {
                    // Reset failure count on success
                    self.failure_counts.remove(&result.plugin_name);
                }

                results.push(result);
            }

            results
        }

        /// Get the number of plugins with disabled hooks.
        pub fn disabled_hook_count(&self) -> usize {
            self.disabled_hooks.len()
        }
    }

    /// Call a plugin hook with timeout.
    ///
    /// Spawns an inner thread for the actual call to enable timeout enforcement.
    ///
    /// # Thread Lifecycle Note
    ///
    /// If the hook hangs beyond the timeout, the inner thread continues running
    /// (orphaned). This is intentional and acceptable because:
    /// 1. Plugins never unload (library stays loaded for process lifetime)
    /// 2. The thread will eventually complete or be terminated with the process
    /// 3. Forcibly terminating threads is unsafe (could leave locks held)
    /// 4. This matches the pattern in version_check.rs for background tasks
    ///
    /// Orphaned threads are logged via the timeout error path. If a plugin
    /// consistently hangs, it will be auto-disabled after 3 consecutive failures.
    fn call_hook_with_timeout(
        plugin: &totui_plugin_interface::Plugin_TO<'static, abi_stable::std_types::RBox<()>>,
        event: FfiEvent,
        timeout: Duration,
    ) -> Result<FfiHookResponse, String> {
        use std::panic::{catch_unwind, AssertUnwindSafe};

        let (tx, rx) = mpsc::channel();
        let event_clone = event.clone();
        let plugin_clone = plugin.clone();

        // Spawn inner thread for the actual hook call.
        // Note: If this thread hangs, it will be orphaned after timeout.
        // This is safe - the thread may continue running but has no references
        // to mutable state (rx is dropped, plugin is cloned).
        thread::spawn(move || {
            let result = catch_unwind(AssertUnwindSafe(|| {
                call_plugin_on_event(&plugin_clone, event_clone)
            }));
            // Ignore send error - receiver may have timed out and dropped
            let _ = tx.send(result);
        });

        // Wait with timeout
        match rx.recv_timeout(timeout) {
            Ok(Ok(result)) => {
                result.into_result().map_err(|e| e.to_string())
            }
            Ok(Err(panic_info)) => {
                let msg = if let Some(s) = panic_info.downcast_ref::<&str>() {
                    format!("Hook panicked: {}", s)
                } else if let Some(s) = panic_info.downcast_ref::<String>() {
                    format!("Hook panicked: {}", s)
                } else {
                    "Hook panicked with unknown error".to_string()
                };
                Err(msg)
            }
            Err(mpsc::RecvTimeoutError::Timeout) => {
                // Inner thread is now orphaned - this is acceptable (see docstring)
                tracing::debug!("Hook thread orphaned after timeout");
                Err("Hook timed out".to_string())
            }
            Err(mpsc::RecvTimeoutError::Disconnected) => {
                Err("Hook thread terminated unexpectedly".to_string())
            }
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn test_hook_dispatcher_new() {
            let dispatcher = HookDispatcher::new();
            assert_eq!(dispatcher.disabled_hook_count(), 0);
            assert!(!dispatcher.is_hook_disabled("test-plugin"));
        }

        #[test]
        fn test_poll_results_empty() {
            let mut dispatcher = HookDispatcher::new();
            let results = dispatcher.poll_results();
            assert!(results.is_empty());
        }

        #[test]
        fn test_hook_result_fields() {
            let result = HookResult {
                plugin_name: "test".to_string(),
                event_type: FfiEventType::OnAdd,
                commands: vec![],
                error: None,
            };
            assert_eq!(result.plugin_name, "test");
            assert!(result.error.is_none());
        }

        #[test]
        fn test_default_constants() {
            assert_eq!(DEFAULT_HOOK_TIMEOUT, Duration::from_secs(5));
            assert_eq!(AUTO_DISABLE_THRESHOLD, 3);
        }
    }
    ```

    Update `src/plugin/mod.rs` to export the hooks module:
    ```rust
    pub mod hooks;
    pub use hooks::{HookDispatcher, HookResult};
    ```
  </action>
  <verify>cargo check && cargo test plugin::hooks</verify>
  <done>HookDispatcher created with dispatch_to_plugin, poll_results, and auto-disable tracking</done>
</task>

<task type="auto">
  <name>Task 3: Add event subscription tracking to PluginLoader</name>
  <files>src/plugin/loader.rs</files>
  <action>
    Extend PluginLoader to track which plugins subscribe to which events:

    1. Add import:
       ```rust
       use totui_plugin_interface::FfiEventType;
       ```

    2. Add field to PluginLoader:
       ```rust
       /// Event subscriptions per plugin (populated at load time).
       event_subscriptions: HashMap<String, Vec<FfiEventType>>,
       ```

    3. Initialize in new() and Default:
       ```rust
       event_subscriptions: HashMap::new(),
       ```

    4. Populate subscriptions in load_all_with_config after successful load:
       ```rust
       // After: self.plugins.insert(plugin_name.to_lowercase(), loaded);
       // Add:
       let subscriptions: Vec<FfiEventType> = loaded.plugin
           .subscribed_events()
           .into_iter()
           .collect();
       if !subscriptions.is_empty() {
           tracing::info!(
               plugin = %plugin_name,
               events = ?subscriptions,
               "Plugin subscribed to events"
           );
       }
       self.event_subscriptions.insert(plugin_name.to_lowercase(), subscriptions);
       ```

    5. Add method to get subscribed plugins for an event type:
       ```rust
       /// Get plugins subscribed to a specific event type.
       ///
       /// Returns list of (plugin_name, timeout_duration) for each subscribed plugin.
       pub fn plugins_for_event(&self, event_type: FfiEventType) -> Vec<(&LoadedPlugin, Duration)> {
           use std::time::Duration;
           use crate::plugin::hooks::DEFAULT_HOOK_TIMEOUT;

           self.event_subscriptions
               .iter()
               .filter(|(_, events)| events.contains(&event_type))
               .filter_map(|(name, _)| {
                   self.plugins.get(name).map(|p| {
                       // Get timeout from manifest if plugin manager available
                       // For now use default - will be wired in plan 03
                       (p, DEFAULT_HOOK_TIMEOUT)
                   })
               })
               .collect()
       }
       ```

    6. Add test:
       ```rust
       #[test]
       fn test_event_subscriptions_empty_on_new() {
           let loader = PluginLoader::new();
           let subs = loader.plugins_for_event(totui_plugin_interface::FfiEventType::OnAdd);
           assert!(subs.is_empty());
       }
       ```
  </action>
  <verify>cargo check && cargo test plugin::loader</verify>
  <done>PluginLoader tracks event subscriptions and provides plugins_for_event() method</done>
</task>

</tasks>

<verification>
1. Run `cargo check` - no errors
2. Run `cargo test` - all tests pass
3. Run `cargo clippy` - no warnings
4. Verify HookDispatcher, HookResult exported from plugin module
5. Verify manifest accepts hook_timeout_secs field
</verification>

<success_criteria>
- HookDispatcher with dispatch_to_plugin() for async hook execution
- poll_results() returns hook results via channel
- Auto-disable after 3 consecutive failures
- call_hook_with_timeout() enforces timeout via recv_timeout
- PluginLoader tracks event subscriptions per plugin
- plugins_for_event() returns subscribed plugins with timeout
- hook_timeout_secs in manifest (default 5)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-event-hooks/13-02-SUMMARY.md`
</output>
