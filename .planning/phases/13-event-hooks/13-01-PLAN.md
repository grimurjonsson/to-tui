---
phase: 13-event-hooks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/totui-plugin-interface/src/events.rs
  - crates/totui-plugin-interface/src/plugin.rs
  - crates/totui-plugin-interface/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "FfiEvent enum exists with OnAdd, OnModify, OnComplete, OnDelete, OnLoad variants"
    - "Plugin trait has subscribed_events() method returning RVec<FfiEventType>"
    - "Plugin trait has on_event() method accepting FfiEvent and returning RResult<FfiHookResponse, RString>"
    - "FfiHookResponse contains RVec<FfiCommand> for hook modifications"
    - "call_plugin_on_event() wrapper provides panic-safe hook invocation"
  artifacts:
    - path: "crates/totui-plugin-interface/src/events.rs"
      provides: "FFI-safe event types for hooks"
      exports: ["FfiEvent", "FfiEventType", "FfiEventSource", "FfiFieldChange", "FfiHookResponse"]
    - path: "crates/totui-plugin-interface/src/plugin.rs"
      provides: "Extended Plugin trait with hook methods"
      contains: "fn subscribed_events"
  key_links:
    - from: "crates/totui-plugin-interface/src/plugin.rs"
      to: "crates/totui-plugin-interface/src/events.rs"
      via: "use crate::events"
      pattern: "use crate::events::"
---

<objective>
Add FFI-safe event types and extend Plugin trait with hook subscription and handling methods.

Purpose: Foundation for event hooks - defines the contract between host and plugins for lifecycle events.
Output: events.rs module with FfiEvent enum, FfiHookResponse type, and Plugin trait methods.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-event-hooks/13-RESEARCH.md
@crates/totui-plugin-interface/src/plugin.rs
@crates/totui-plugin-interface/src/host_api.rs
@crates/totui-plugin-interface/src/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create events.rs with FFI-safe event types</name>
  <files>crates/totui-plugin-interface/src/events.rs</files>
  <action>
    Create new module `events.rs` with:

    1. FfiEventType enum (#[repr(u8)], StableAbi):
       - OnAdd = 0
       - OnModify = 1
       - OnComplete = 2
       - OnDelete = 3
       - OnLoad = 4

    2. FfiEventSource enum (#[repr(u8)], StableAbi):
       - Manual = 0
       - Rollover = 1
       - Plugin = 2
       - Api = 3

    3. FfiFieldChange enum (#[repr(u8)], StableAbi):
       - Content = 0
       - State = 1
       - DueDate = 2
       - Priority = 3
       - Description = 4
       - Indent = 5
       - Parent = 6
       - Multiple = 7

    4. FfiEvent enum (#[repr(C)], StableAbi, Clone):
       - OnAdd { todo: FfiTodoItem, source: FfiEventSource }
       - OnModify { todo: FfiTodoItem, field_changed: FfiFieldChange }
       - OnComplete { todo: FfiTodoItem }
       - OnDelete { todo: FfiTodoItem }
       - OnLoad { project_name: RString, date: RString }

    5. FfiHookResponse struct (#[repr(C)], StableAbi, Clone):
       - commands: RVec<FfiCommand>
       - impl Default returning empty commands vec

    Use RString from abi_stable::std_types.
    Import FfiTodoItem from crate::types.
    Import FfiCommand from crate::host_api.
  </action>
  <verify>cargo check -p totui-plugin-interface</verify>
  <done>events.rs compiles with all FFI-safe event types defined</done>
</task>

<task type="auto">
  <name>Task 2: Extend Plugin trait with hook methods</name>
  <files>crates/totui-plugin-interface/src/plugin.rs, crates/totui-plugin-interface/src/lib.rs</files>
  <action>
    1. Add import to plugin.rs:
       ```rust
       use crate::events::{FfiEvent, FfiEventType, FfiHookResponse};
       ```

    2. Add two new methods to the Plugin trait:
       ```rust
       /// Return event types this plugin wants to receive.
       /// Empty vec means plugin subscribes to no events.
       /// Called once at plugin load time.
       fn subscribed_events(&self) -> RVec<FfiEventType>;

       /// Handle an event hook.
       /// Called asynchronously - should complete quickly (timeout applies).
       /// Returns commands to apply (or empty vec for no-op).
       #[sabi(last_prefix_field)]
       fn on_event(&self, event: FfiEvent) -> RResult<FfiHookResponse, RString>;
       ```

       Note: Move #[sabi(last_prefix_field)] from on_config_loaded to on_event.
       This marker must be on the LAST method in the trait for ABI extensibility.

    3. Add panic-safe wrapper function:
       ```rust
       /// Wrapper for calling plugin.on_event() safely.
       pub fn call_plugin_on_event(
           plugin: &Plugin_TO<'_, RBox<()>>,
           event: FfiEvent,
       ) -> RResult<FfiHookResponse, RString> {
           let result = catch_unwind(AssertUnwindSafe(|| plugin.on_event(event)));
           match result {
               Ok(r) => r,
               Err(panic_info) => {
                   let msg = if let Some(s) = panic_info.downcast_ref::<&str>() {
                       format!("Plugin hook panicked: {}", s)
                   } else if let Some(s) = panic_info.downcast_ref::<String>() {
                       format!("Plugin hook panicked: {}", s)
                   } else {
                       "Plugin hook panicked with unknown error".to_string()
                   };
                   RResult::RErr(msg.into())
               }
           }
       }
       ```

    4. Update lib.rs to export events module and types:
       ```rust
       pub mod events;
       pub use events::{FfiEvent, FfiEventType, FfiEventSource, FfiFieldChange, FfiHookResponse};
       ```

       Also add call_plugin_on_event to the re-exports from plugin module.
  </action>
  <verify>cargo check -p totui-plugin-interface && cargo test -p totui-plugin-interface</verify>
  <done>Plugin trait has subscribed_events and on_event methods, call_plugin_on_event exported</done>
</task>

<task type="auto">
  <name>Task 3: Add helper methods to FfiEvent</name>
  <files>crates/totui-plugin-interface/src/events.rs</files>
  <action>
    Add impl block for FfiEvent with helper methods:

    ```rust
    impl FfiEvent {
        /// Get the event type for this event.
        pub fn event_type(&self) -> FfiEventType {
            match self {
                FfiEvent::OnAdd { .. } => FfiEventType::OnAdd,
                FfiEvent::OnModify { .. } => FfiEventType::OnModify,
                FfiEvent::OnComplete { .. } => FfiEventType::OnComplete,
                FfiEvent::OnDelete { .. } => FfiEventType::OnDelete,
                FfiEvent::OnLoad { .. } => FfiEventType::OnLoad,
            }
        }

        /// Get the todo item if this event contains one.
        pub fn todo(&self) -> Option<&FfiTodoItem> {
            match self {
                FfiEvent::OnAdd { todo, .. } => Some(todo),
                FfiEvent::OnModify { todo, .. } => Some(todo),
                FfiEvent::OnComplete { todo } => Some(todo),
                FfiEvent::OnDelete { todo } => Some(todo),
                FfiEvent::OnLoad { .. } => None,
            }
        }
    }
    ```

    Add unit tests:
    ```rust
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::types::{FfiTodoItem, FfiTodoState};

        fn make_test_todo() -> FfiTodoItem {
            FfiTodoItem {
                id: "test-id".into(),
                content: "Test todo".into(),
                state: FfiTodoState::Empty,
                // ... other fields with defaults
            }
        }

        #[test]
        fn test_event_type() {
            let todo = make_test_todo();
            let event = FfiEvent::OnAdd { todo, source: FfiEventSource::Manual };
            assert!(matches!(event.event_type(), FfiEventType::OnAdd));
        }

        #[test]
        fn test_hook_response_default() {
            let response = FfiHookResponse::default();
            assert!(response.commands.is_empty());
        }
    }
    ```
  </action>
  <verify>cargo test -p totui-plugin-interface</verify>
  <done>FfiEvent has event_type() and todo() helpers, tests pass</done>
</task>

</tasks>

<verification>
1. Run `cargo check -p totui-plugin-interface` - no errors
2. Run `cargo test -p totui-plugin-interface` - all tests pass
3. Run `cargo clippy -p totui-plugin-interface` - no warnings
4. Verify FfiEvent, FfiHookResponse, FfiEventType exported from crate root
</verification>

<success_criteria>
- FfiEvent enum with 5 variants (OnAdd, OnModify, OnComplete, OnDelete, OnLoad)
- FfiEventType enum for subscription
- FfiHookResponse struct with RVec<FfiCommand>
- Plugin trait extended with subscribed_events() and on_event() methods
- call_plugin_on_event() panic-safe wrapper function
- All types derive StableAbi for FFI safety
- Unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-event-hooks/13-01-SUMMARY.md`
</output>
