---
phase: 02-scrolling-mouse-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/app/state.rs, src/ui/components/todo_list.rs]
autonomous: true

must_haves:
  truths:
    - "Todo list scrolls when items exceed terminal height"
    - "Cursor stays visible when navigating up/down"
    - "Selection highlighting renders correctly with scroll offset"
  artifacts:
    - path: "src/app/state.rs"
      provides: "ListState field for scroll tracking"
      contains: "list_state"
    - path: "src/ui/components/todo_list.rs"
      provides: "StatefulWidget rendering with scroll support"
      contains: "StatefulWidget::render"
  key_links:
    - from: "src/app/state.rs"
      to: "src/ui/components/todo_list.rs"
      via: "list_state passed to render function"
      pattern: "list_state"
---

<objective>
Add scroll state tracking to AppState and update todo list rendering to use ratatui's StatefulWidget pattern for automatic scroll management.

Purpose: Enable vertical scrolling when todo list exceeds terminal height, keeping cursor visible during navigation.
Output: Todo list widget that scrolls to keep selected item in view.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/app/state.rs
@src/ui/components/todo_list.rs
@src/ui/components/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ListState to AppState</name>
  <files>src/app/state.rs</files>
  <action>
    1. Add `use ratatui::widgets::ListState;` import
    2. Add `list_state: ListState` field to AppState struct
    3. Initialize in `AppState::new()` with `ListState::default()`
    4. Add method `sync_list_state(&mut self)` that:
       - Counts visible items (excluding hidden collapsed children)
       - Sets `self.list_state.select(Some(visible_index))` where visible_index is the cursor's position among visible items only
    5. Call `sync_list_state()` at end of `move_cursor_up()`, `move_cursor_down()`, `clamp_cursor()`, `navigate_to_date()`

    NOTE: The visible_index calculation must skip hidden indices. Use the same logic as `build_hidden_indices()` from TodoList to determine which items are visible, then find the cursor's position in that filtered list.
  </action>
  <verify>cargo build --release passes without errors</verify>
  <done>AppState has ListState field that tracks cursor position among visible items</done>
</task>

<task type="auto">
  <name>Task 2: Update todo_list.rs to use StatefulWidget</name>
  <files>src/ui/components/todo_list.rs</files>
  <action>
    1. Change render function signature from `render(f: &mut Frame, state: &AppState, area: Rect)` to `render(f: &mut Frame, state: &mut AppState, area: Rect)` (need mutable for ListState)
    2. Replace `f.render_widget(list, area);` with `f.render_stateful_widget(list, area, &mut state.list_state);`
    3. Add `.highlight_style()` to the List builder to show which item is selected (use REVERSED modifier like current cursor styling)
    4. Remove the manual cursor highlighting logic from `compute_item_style` - let ListState handle selection via highlight_style

    IMPORTANT: Keep existing item styling (checked=gray, question=yellow, etc.) - only remove the REVERSED modifier for cursor since ListState will handle that via highlight_style.

    NOTE: The current implementation manually applies REVERSED to the cursor item. With StatefulWidget, we set highlight_style on the List widget instead, and ratatui applies it to whichever item ListState.selected() points to.
  </action>
  <verify>cargo build --release passes; cargo run shows todo list with working cursor movement</verify>
  <done>Todo list renders using StatefulWidget with automatic scroll-to-cursor behavior</done>
</task>

<task type="auto">
  <name>Task 3: Update render call sites for mutable state</name>
  <files>src/ui/components/mod.rs</files>
  <action>
    1. Find where `todo_list::render` is called
    2. Update the call to pass `&mut state` instead of `&state` if needed
    3. Ensure the parent render function also takes `&mut AppState`
    4. Trace up the call chain and update signatures as needed (likely in mod.rs render function)

    The call chain is typically: ui/mod.rs run_app -> components::render -> todo_list::render
    All need mutable references for ListState to work.
  </action>
  <verify>cargo build --release passes; cargo run shows scrolling works when list exceeds terminal height</verify>
  <done>Full render chain supports mutable AppState for ListState updates</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build --release` succeeds without errors
- [ ] `cargo clippy` passes with no warnings
- [ ] `cargo test` passes (existing tests)
- [ ] Manual test: Create 50+ todos, verify list scrolls when navigating with j/k
- [ ] Manual test: Cursor always stays visible when moving up/down
- [ ] Manual test: Visual mode selection still works correctly
</verification>

<success_criteria>
- All tasks completed
- ListState tracks cursor position among visible items
- Todo list uses StatefulWidget rendering
- Scrolling works automatically when cursor moves outside viewport
- No regressions in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/02-scrolling-mouse-support/02-01-SUMMARY.md`
</output>
