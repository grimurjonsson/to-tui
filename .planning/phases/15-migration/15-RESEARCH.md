# Phase 15: Migration - Research

**Researched:** 2026-01-26
**Domain:** Plugin extraction, registry publication, TUI modal redesign
**Confidence:** HIGH

## Summary

This phase migrates the existing built-in Jira generator to the first external plugin in the grimurjonsson/to-tui-plugins registry. The work spans three domains: (1) creating the jira-claude plugin as a standalone Rust crate with abi_stable bindings, (2) removing the built-in generator code from to-tui, and (3) redesigning the P-key modal from a simple generator list to a tab-based plugins modal with [Installed] and [Marketplace] views.

The codebase already has all necessary infrastructure: the plugin interface (`totui-plugin-interface`), installer (`src/plugin/installer.rs`), marketplace manifest parsing (`src/plugin/marketplace.rs`), and plugin manager (`src/plugin/manager.rs`). The primary work is extraction and refactoring rather than building new systems.

**Primary recommendation:** Extract jira_claude.rs logic into a new crate that implements the Plugin trait, builds as cdylib, and uses GitHub Actions with cross-rs for multi-platform releases. Replace the current PluginSubState with a new tabbed modal using ratatui's Tabs widget.

## Standard Stack

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| totui-plugin-interface | 0.1.0 | Plugin ABI contract | Existing crate, defines Plugin trait for external plugins |
| abi_stable | 0.11 | FFI-safe trait objects | Already used in interface crate |
| serde + serde_json | 1.0 | JSON parsing for acli output | Standard for Rust JSON, already in workspace |
| ratatui | 0.30 | TUI framework (Tabs widget) | Already used throughout, provides Tabs widget for modal |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| cross | 0.2+ | Cross-compilation in CI | Building plugin for Linux/macOS/Windows targets |
| reqwest (blocking) | 0.12 | HTTP for marketplace fetch | Already in to-tui for installer |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| cross (CI) | cargo with targets | cross simplifies Linux ARM builds without custom containers |
| Plugin trait | WASM | User decided abi_stable in v2.0 decisions; WASM rejected |

**Installation (for jira-claude plugin):**
```toml
[dependencies]
totui-plugin-interface = { git = "https://github.com/grimurjonsson/to-tui", tag = "v0.4.0" }
abi_stable = "0.11"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

[lib]
crate-type = ["cdylib"]
```

## Architecture Patterns

### Recommended Plugin Repository Structure

```
grimurjonsson/to-tui-plugins/
├── marketplace.toml              # Auto-generated by CI
├── README.md                     # Auto-generated from marketplace.toml
├── LICENSE                       # MIT
├── .github/
│   └── workflows/
│       ├── release.yml           # Per-plugin release triggered by tags
│       └── marketplace-update.yml # Updates marketplace.toml after release
└── jira-claude/
    ├── Cargo.toml
    ├── README.md                 # Plugin-specific docs
    ├── CHANGELOG.md              # Per-plugin changelog
    └── src/
        └── lib.rs                # Plugin implementation
```

### Pattern 1: Plugin Entry Point (export_root_module)

**What:** Every external plugin must export a root module using abi_stable's macro
**When to use:** Required for all plugins
**Example:**
```rust
// Source: totui-plugin-interface/src/version.rs pattern
use totui_plugin_interface::{PluginModule, PluginModule_Ref, Plugin_TO};
use abi_stable::{export_root_module, prefix_type::PrefixTypeTrait, std_types::RBox, sabi_trait::TD_Opaque};

#[export_root_module]
fn get_library() -> PluginModule_Ref {
    PluginModule {
        create_plugin,
    }.leak_into_prefix()
}

extern "C" fn create_plugin() -> Plugin_TO<'static, RBox<()>> {
    Plugin_TO::from_value(JiraClaudePlugin::new(), TD_Opaque)
}
```

### Pattern 2: Tabbed Modal with Tabs Widget

**What:** Replace current plugin list with tab-based navigation
**When to use:** P-key plugins modal
**Example:**
```rust
// Source: Context7 ratatui Tabs widget documentation
use ratatui::widgets::{Block, Tabs, List, ListItem};
use ratatui::style::{Color, Modifier, Style};

// Tab titles
let tab_titles = vec!["Installed", "Marketplace"];

// Render tabs
let tabs = Tabs::new(tab_titles)
    .block(Block::bordered().title(" Plugins "))
    .select(tab_index)
    .style(Style::new().fg(Color::White))
    .highlight_style(
        Style::new()
            .fg(Color::Cyan)
            .add_modifier(Modifier::BOLD | Modifier::UNDERLINED)
    )
    .divider(" | ");

frame.render_widget(tabs, tabs_area);
```

### Pattern 3: GitHub Actions Plugin Release Workflow

**What:** CI workflow that builds cdylib for multiple platforms on git tag
**When to use:** Plugin releases (jira-claude-v1.0.0 tag format)
**Example:**
```yaml
# Source: Existing to-tui release.yml + cross-compilation best practices
name: Release Plugin

on:
  push:
    tags:
      - 'jira-claude-v*'

jobs:
  build-and-release:
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            use_cross: true
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            use_cross: true
          - os: macos-latest
            target: x86_64-apple-darwin
            use_cross: false
          - os: macos-latest
            target: aarch64-apple-darwin
            use_cross: false
          - os: ubuntu-latest
            target: x86_64-pc-windows-gnu
            use_cross: true
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
      - name: Install cross
        if: matrix.use_cross
        run: cargo install cross --git https://github.com/cross-rs/cross
      - name: Build
        run: |
          cd jira-claude
          if [ "${{ matrix.use_cross }}" = "true" ]; then
            cross build --release --target ${{ matrix.target }}
          else
            cargo build --release --target ${{ matrix.target }}
          fi
      - name: Package
        run: |
          mkdir -p release-assets
          # Create tar.gz with plugin.toml + library
          tar -czvf release-assets/jira-claude-${{ matrix.target }}.tar.gz \
            -C jira-claude plugin.toml README.md \
            -C ../target/${{ matrix.target }}/release libjira_claude.{so,dylib,dll} 2>/dev/null || true
      - uses: softprops/action-gh-release@v2
        with:
          files: release-assets/*
```

### Pattern 4: PluginSubState Redesign

**What:** New state machine for tab-based plugins modal
**When to use:** Replacing current PluginSubState
**Example:**
```rust
// New PluginsModalState replacing PluginSubState
pub enum PluginsModalState {
    // Tab selection mode
    Tabs {
        active_tab: PluginsTab,
        installed_index: usize,
        marketplace_index: usize,
        marketplace_plugins: Option<Vec<MarketplacePlugin>>,
        marketplace_loading: bool,
    },
    // Plugin details view (from Marketplace tab)
    Details {
        plugin: MarketplacePlugin,
    },
    // Plugin input (invoking installed plugin)
    Input {
        plugin_name: String,
        input_buffer: String,
        cursor_pos: usize,
    },
    // Executing plugin
    Executing {
        plugin_name: String,
    },
    // Preview generated items
    Preview {
        items: Vec<TodoItem>,
    },
    // Error display
    Error {
        message: String,
    },
}

pub enum PluginsTab {
    Installed,
    Marketplace,
}
```

### Anti-Patterns to Avoid

- **Keeping JiraClaudeGenerator in binary:** User decision is explicit removal. Don't leave dead code behind feature flags.
- **Symlink for plugin source:** User decision in 14-01 was copy, not symlinks. Windows compatibility requires full copy.
- **Mixed tab navigation:** Tab/Shift+Tab for tabs, j/k for list. Don't use arrows for both.
- **Blocking marketplace fetch:** Must be async with loading spinner. Don't freeze UI during network calls.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Subprocess execution | Custom fork/exec | `std::process::Command` | Already pattern in subprocess.rs |
| JSON parsing | Manual string parsing | `serde_json` | Existing in jira_claude.rs |
| Cross-compilation | Custom Docker containers | `cross-rs` project | Handles toolchains, linkers automatically |
| Tab widget | Custom selection logic | `ratatui::widgets::Tabs` | Built-in, well-tested |
| Marketplace manifest | Custom format | Existing `marketplace.rs` | Phase 14 already built this |

**Key insight:** The existing codebase already implements most of the machinery. The main work is reorganization and extraction rather than new features.

## Common Pitfalls

### Pitfall 1: Library Naming Conventions

**What goes wrong:** Plugin library not found due to platform-specific naming
**Why it happens:** Linux uses lib*.so, macOS uses lib*.dylib, Windows uses *.dll
**How to avoid:** Use consistent naming in tar.gz: include whichever extension exists
**Warning signs:** "Library not found" errors on specific platforms

### Pitfall 2: Cargo.toml crate-type Missing

**What goes wrong:** Build produces rlib instead of cdylib
**Why it happens:** Forgot `crate-type = ["cdylib"]` in plugin's Cargo.toml
**How to avoid:** Template plugin.toml in documentation
**Warning signs:** Very small binary, missing expected symbols

### Pitfall 3: Marketplace Fetch Blocking UI

**What goes wrong:** TUI freezes when opening Marketplace tab
**Why it happens:** Blocking HTTP request on main thread
**How to avoid:** Spawn thread for fetch, use channel pattern like upgrade.rs
**Warning signs:** Unresponsive UI, cursor not moving during fetch

### Pitfall 4: Tab State Lost on Tab Switch

**What goes wrong:** Scrolling position resets when switching tabs
**Why it happens:** Not persisting per-tab selection state
**How to avoid:** Store separate indices (installed_index, marketplace_index) in state
**Warning signs:** User loses place in long list after tab switch

### Pitfall 5: Built-in Generator Not Fully Removed

**What goes wrong:** Binary size unchanged, old P-key behavior persists
**Why it happens:** Incomplete removal - generator still registered
**How to avoid:** Search for all JiraClaudeGenerator references, remove mod.rs export
**Warning signs:** `totui plugin list` still shows "jira" as built-in

## Code Examples

### Jira-Claude Plugin Implementation (Core Structure)

```rust
// Source: Derived from existing src/plugin/generators/jira_claude.rs
use totui_plugin_interface::{
    Plugin, FfiTodoItem, FfiTodoState, FfiConfigSchema, FfiConfigValue,
    FfiEvent, FfiEventType, FfiHookResponse, FfiCommand, HostApi_TO,
};
use abi_stable::std_types::{RBox, RHashMap, RResult, RString, RVec};
use std::fmt::Debug;
use std::process::Command;

#[derive(Debug)]
pub struct JiraClaudePlugin;

impl JiraClaudePlugin {
    pub fn new() -> Self {
        Self
    }

    fn fetch_jira_ticket(&self, ticket_id: &str) -> Result<JiraTicket, String> {
        // Same logic as existing jira_claude.rs
        let output = Command::new("acli")
            .args(["jira", "workitem", "view", ticket_id, "--fields", "key,summary,description,comment", "--json"])
            .output()
            .map_err(|e| format!("Failed to run acli: {}", e))?;
        // ... parse JSON
        todo!()
    }

    fn generate_with_claude(&self, ticket: &JiraTicket) -> Result<Vec<GeneratedTodo>, String> {
        let prompt = self.build_prompt(ticket);
        let output = Command::new("claude")
            .args(["-p", &prompt])
            .output()
            .map_err(|e| format!("Failed to run claude: {}", e))?;
        // ... parse output
        todo!()
    }
}

impl Plugin for JiraClaudePlugin {
    fn name(&self) -> RString {
        "jira-claude".into()
    }

    fn version(&self) -> RString {
        "0.1.0".into()
    }

    fn min_interface_version(&self) -> RString {
        "0.1.0".into()
    }

    fn generate(&self, input: RString) -> RResult<RVec<FfiTodoItem>, RString> {
        let ticket_id = input.to_string().trim().to_uppercase();

        let ticket = match self.fetch_jira_ticket(&ticket_id) {
            Ok(t) => t,
            Err(e) => return RResult::RErr(e.into()),
        };

        let generated = match self.generate_with_claude(&ticket) {
            Ok(g) => g,
            Err(e) => return RResult::RErr(e.into()),
        };

        // Convert to FfiTodoItem
        let items: Vec<FfiTodoItem> = generated.into_iter()
            .map(|g| FfiTodoItem {
                content: g.content.into(),
                state: FfiTodoState::Empty,
                indent_level: g.indent_level,
                // ... other fields
            })
            .collect();

        RResult::ROk(items.into())
    }

    fn config_schema(&self) -> FfiConfigSchema {
        FfiConfigSchema::empty()
    }

    fn execute_with_host(
        &self,
        input: RString,
        _host: HostApi_TO<'_, RBox<()>>,
    ) -> RResult<RVec<FfiCommand>, RString> {
        // For this plugin, generate() is the primary entry
        RResult::ROk(RVec::new())
    }

    fn on_config_loaded(&self, _config: RHashMap<RString, FfiConfigValue>) {
        // No config needed
    }

    fn subscribed_events(&self) -> RVec<FfiEventType> {
        RVec::new()
    }

    fn on_event(&self, _event: FfiEvent) -> RResult<FfiHookResponse, RString> {
        RResult::ROk(FfiHookResponse::default())
    }
}
```

### marketplace.toml Schema (CI-Generated)

```toml
# Source: Existing marketplace.rs + user decisions
[marketplace]
name = "to-tui-plugins"
description = "Official plugin registry for to-tui"
url = "https://github.com/grimurjonsson/to-tui-plugins"

[[plugins]]
name = "jira-claude"
description = "Generate todos from Jira tickets using Claude AI"
version = "0.1.0"
# Download URLs per platform (populated by CI)
# Format: https://github.com/{owner}/{repo}/releases/download/{tag}/{plugin}-{target}.tar.gz
```

### Installed Tab Plugin Status Colors

```rust
// Source: User decision - visual status indicators
fn get_plugin_status_style(info: &PluginInfo) -> Style {
    if info.error.is_some() {
        Style::default().fg(Color::Red)  // Red = error
    } else if !info.enabled {
        Style::default().fg(Color::Yellow)  // Yellow = disabled
    } else if !info.available {
        Style::default().fg(Color::Yellow)  // Yellow = incompatible
    } else {
        Style::default().fg(Color::Green)  // Green = active
    }
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Built-in generators | External plugins via registry | Phase 15 | Jira logic moves to separate repo |
| P opens generator list | P opens tabbed plugins modal | Phase 15 | New UX with Installed/Marketplace tabs |
| Generator-specific input | Plugin actions via keybindings | Phase 12-13 | Plugins can register actions |

**Deprecated/outdated:**
- `src/plugin/generators/`: Entire module to be removed
- `PluginRegistry::register_builtin_generators()`: Remove call in `mod.rs`
- `PluginSubState` variants for old generator flow: Replace with new state machine

## Open Questions

1. **How to handle concurrent marketplace fetch?**
   - What we know: Must not block UI, need loading state
   - What's unclear: Use mpsc channel like upgrade.rs or spawn with Arc<Mutex>?
   - Recommendation: Use mpsc channel pattern matching existing upgrade.rs download flow

2. **Details view depth from Marketplace tab**
   - What we know: User wants to see name, version, description, author, permissions, keybindings, config options
   - What's unclear: How much info goes in marketplace.toml vs fetched from plugin manifest?
   - Recommendation: Keep marketplace.toml minimal (name, version, description, URLs). For full details, download plugin.toml from release assets.

3. **plugin.toml location in release archive**
   - What we know: tar.gz contains plugin binary
   - What's unclear: Should plugin.toml be in archive root or nested?
   - Recommendation: Archive root for simplicity. Matches existing installer expectations.

## Sources

### Primary (HIGH confidence)
- Existing codebase: `/Users/gimmi/Documents/Sources/rust/to-tui/src/plugin/generators/jira_claude.rs` - Source code to extract
- Existing codebase: `/Users/gimmi/Documents/Sources/rust/to-tui/crates/totui-plugin-interface/src/plugin.rs` - Plugin trait definition
- Existing codebase: `/Users/gimmi/Documents/Sources/rust/to-tui/src/plugin/installer.rs` - Remote install pattern
- Existing codebase: `/Users/gimmi/Documents/Sources/rust/to-tui/.github/workflows/release.yml` - CI release pattern
- [Context7 ratatui Tabs widget](https://context7.com/ratatui/ratatui/llms.txt) - Tab navigation pattern

### Secondary (MEDIUM confidence)
- [houseabsolute/actions-rust-cross](https://github.com/houseabsolute/actions-rust-cross) - GitHub Action for cross-compilation
- [Cross-Compiling Rust in GitHub Actions](https://blog.urth.org/2023/03/05/cross-compiling-rust-projects-in-github-actions/) - CI best practices

### Tertiary (LOW confidence)
- None - all findings verified against existing codebase or official docs

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already in use in codebase
- Architecture: HIGH - Patterns derived from existing code (installer, release workflow, UI components)
- Pitfalls: HIGH - Based on existing patterns and user decisions from CONTEXT.md

**Research date:** 2026-01-26
**Valid until:** 2026-02-26 (stable patterns, no external dependencies changing)
