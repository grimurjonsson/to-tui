---
phase: 08-dynamic-loading
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/app/state.rs
  - src/ui/components/mod.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "Plugin loading errors show popup at startup with 'Run totui plugin status for details' hint"
    - "Plugin panics during operation show error popup with plugin name and message"
    - "TUI renders first, then loads plugins (user sees the interface immediately)"
    - "Loading errors persist across launches - error shows each startup until user fixes or disables plugin"
    - "Runtime panics disable plugin for current session only (session_disabled flag)"
  artifacts:
    - path: "src/app/state.rs"
      provides: "Plugin loading state fields (pending_plugin_errors, show_plugin_error_popup, plugin_loader)"
      contains: "pending_plugin_errors"
    - path: "src/ui/components/mod.rs"
      provides: "render_plugin_error_popup function"
      contains: "render_plugin_error_popup"
    - path: "src/main.rs"
      provides: "Plugin loading during startup with error collection"
      contains: "PluginLoader"
  key_links:
    - from: "src/main.rs"
      to: "src/plugin/loader.rs"
      via: "PluginLoader::new() and load_all()"
      pattern: "PluginLoader::new"
    - from: "src/ui/components/mod.rs"
      to: "src/app/state.rs"
      via: "pending_plugin_errors field"
      pattern: "pending_plugin_errors"
---

<objective>
Integrate plugin loading into the TUI application with proper error display, startup experience, and panic notifications.

Purpose: Users see plugin loading failures clearly at startup and runtime, with actionable hints for debugging.
Output: TUI that loads plugins after first render and displays error popups for failures.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-dynamic-loading/08-CONTEXT.md
@.planning/phases/08-dynamic-loading/08-RESEARCH.md
@.planning/phases/08-dynamic-loading/08-01-SUMMARY.md
@src/app/state.rs
@src/ui/components/mod.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add plugin loading state to AppState</name>
  <files>src/app/state.rs</files>
  <action>
Add fields to AppState for plugin loading state:

1. **Add imports** at top of file:
```rust
use crate::plugin::{PluginLoader, PluginLoadError};
```

2. **Add fields to AppState struct**:
```rust
/// Plugin loader with dynamically loaded plugins
pub plugin_loader: PluginLoader,
/// Plugin loading errors to display on first render
pub pending_plugin_errors: Vec<PluginLoadError>,
/// Whether to show plugin error popup
pub show_plugin_error_popup: bool,
```

3. **Update AppState::new()** to accept plugin_loader and errors:
   - Add parameters: `plugin_loader: PluginLoader, plugin_errors: Vec<PluginLoadError>`
   - Initialize the new fields:
     ```rust
     show_plugin_error_popup: !plugin_errors.is_empty(),
     pending_plugin_errors: plugin_errors,
     plugin_loader,
     ```

4. **Add method to dismiss plugin error popup**:
```rust
pub fn dismiss_plugin_error_popup(&mut self) {
    self.show_plugin_error_popup = false;
    // Note: errors stay in pending_plugin_errors for totui plugin status
}
```

5. **Add method to handle plugin panic** (called when runtime panic occurs):
```rust
pub fn handle_plugin_panic(&mut self, error: PluginLoadError) {
    // Add to pending errors for display
    self.pending_plugin_errors.push(error);
    self.show_plugin_error_popup = true;
}
```
  </action>
  <verify>
`cargo build` compiles (will have errors until main.rs is updated, that's expected).
  </verify>
  <done>
AppState has plugin_loader, pending_plugin_errors, and show_plugin_error_popup fields.
dismiss_plugin_error_popup() and handle_plugin_panic() methods exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add plugin error popup UI component</name>
  <files>src/ui/components/mod.rs</files>
  <action>
Add plugin error popup rendering to `src/ui/components/mod.rs`:

1. **Add import** for PluginLoadError:
```rust
use crate::plugin::PluginLoadError;
```

2. **Add render_plugin_error_popup function** (follow existing overlay patterns like render_plugin_error):
```rust
pub fn render_plugin_error_popup(f: &mut Frame, state: &AppState) {
    if !state.show_plugin_error_popup || state.pending_plugin_errors.is_empty() {
        return;
    }

    let errors = &state.pending_plugin_errors;
    let area = f.area();

    // Center popup, 65% width, height based on error count (max 60% of screen)
    let popup_width = (area.width * 65) / 100;
    let content_lines = errors.len() * 2 + 6;  // 2 lines per error + header/footer
    let popup_height = (content_lines as u16 + 4).min((area.height * 60) / 100);

    let popup_layout = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length((area.height - popup_height) / 2),
            Constraint::Length(popup_height),
            Constraint::Min(0),
        ])
        .split(area);

    let popup_area = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Length((area.width - popup_width) / 2),
            Constraint::Length(popup_width),
            Constraint::Min(0),
        ])
        .split(popup_layout[1])[1];

    // Clear background
    f.render_widget(Clear, popup_area);

    // Build error text
    let mut lines = vec![
        Line::from(Span::styled(
            format!("{} plugin(s) failed to load:", errors.len()),
            Style::default().add_modifier(Modifier::BOLD),
        )),
        Line::from(""),
    ];

    for error in errors {
        lines.push(Line::from(vec![
            Span::styled("  - ", Style::default().fg(Color::Red)),
            Span::styled(&error.plugin_name, Style::default().add_modifier(Modifier::BOLD)),
        ]));
        lines.push(Line::from(vec![
            Span::raw("    "),
            Span::styled(&error.message, Style::default().fg(Color::DarkGray)),
        ]));
    }

    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled(
        "Run `totui plugin status` for details",
        Style::default().fg(Color::DarkGray).add_modifier(Modifier::ITALIC),
    )));
    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled(
        "Press any key to dismiss",
        Style::default().fg(Color::Yellow),
    )));

    let paragraph = Paragraph::new(lines)
        .block(Block::default()
            .title(" Plugin Loading Errors ")
            .borders(Borders::ALL)
            .border_style(Style::default().fg(Color::Red)))
        .wrap(Wrap { trim: false })
        .style(Style::default().bg(state.theme.background));

    f.render_widget(paragraph, popup_area);
}
```

3. **Add call in render() function** after other overlays but before mode-specific overlays:
```rust
// Add after render_rollover_overlay check, before mode checks
if state.show_plugin_error_popup {
    render_plugin_error_popup(f, state);
}
```
  </action>
  <verify>
`cargo build` compiles without errors.
  </verify>
  <done>
render_plugin_error_popup() displays error list with hint to run `totui plugin status`.
Popup rendered when show_plugin_error_popup is true.
Error messages show plugin name and description on separate lines.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate plugin loading into main.rs startup</name>
  <files>src/main.rs</files>
  <action>
Integrate PluginLoader into TUI startup in `src/main.rs`:

1. **Add import** for PluginLoader:
```rust
use totui::plugin::{PluginLoader, PluginManager};
```

2. **In the TUI startup code** (where AppState is created), add plugin loading AFTER PluginManager discovery:
```rust
// Discover plugins and load config
let mut plugin_manager = PluginManager::discover()?;
plugin_manager.apply_config(&config.plugins);

// Load dynamic plugins
let mut plugin_loader = PluginLoader::new();
let plugin_errors = plugin_loader.load_all(&plugin_manager);

if !plugin_errors.is_empty() {
    tracing::warn!("{} plugin(s) failed to load", plugin_errors.len());
    for error in &plugin_errors {
        tracing::debug!("Plugin error: {} - {}", error.plugin_name, error.message);
    }
}
```

3. **Update AppState::new() call** to pass plugin_loader and plugin_errors:
```rust
let mut state = AppState::new(
    todo_list,
    theme,
    keybindings,
    config.timeoutlen,
    plugin_registry,  // existing
    ui_cache,
    config.skipped_version.clone(),
    current_project,
    plugin_loader,     // NEW
    plugin_errors,     // NEW
);
```

4. **Add key handling for dismissing plugin error popup** in the event loop:
   - When `show_plugin_error_popup` is true and any key is pressed, call `state.dismiss_plugin_error_popup()`
   - This should be checked BEFORE normal key handling
```rust
// In event handling, early in the match:
if state.show_plugin_error_popup {
    state.dismiss_plugin_error_popup();
    continue;  // Consume the key event
}
```

5. **Ensure TUI renders before blocking** - The current architecture already renders before blocking on input, so this should work correctly. Plugins load during startup but the first render happens immediately.
  </action>
  <verify>
`cargo build --release` compiles without errors.
`cargo run` starts the TUI (may show empty plugin error popup if no plugins installed, which is correct).
  </verify>
  <done>
PluginLoader created during startup after PluginManager discovery.
Plugin loading errors passed to AppState.
Error popup dismisses on any key press.
TUI renders before plugin loading blocks (startup feels responsive).
  </done>
</task>

</tasks>

<verification>
Run all verification commands:
```bash
cargo build --release
cargo test --lib
cargo clippy -- -D warnings
```

Manual verification:
1. Run `cargo run` - TUI should start and render immediately
2. If no plugins installed, no error popup (empty list)
3. Plugin loading happens during startup (check logs with RUST_LOG=debug)
</verification>

<success_criteria>
1. AppState has plugin_loader and error tracking fields
2. Plugin error popup renders with error list and status command hint
3. Any key dismisses the error popup
4. Plugin loading integrated into main.rs startup
5. TUI renders first, plugin loading happens during startup
6. Errors logged with tracing for debugging
</success_criteria>

<output>
After completion, create `.planning/phases/08-dynamic-loading/08-02-SUMMARY.md`
</output>
