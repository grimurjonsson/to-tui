---
phase: 08-dynamic-loading
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/plugin/loader.rs
  - src/plugin/mod.rs
  - Cargo.toml
autonomous: true

must_haves:
  truths:
    - "PluginLoader can load .so/.dylib/.dll plugins using abi_stable"
    - "Plugin panics are caught and do not crash the host"
    - "Loading errors are captured with clear messages (version mismatch vs corruption)"
    - "Panicked plugins are disabled for the session to prevent repeated crashes"
  artifacts:
    - path: "src/plugin/loader.rs"
      provides: "PluginLoader struct with load_all(), call_safely(), panic logging"
      exports: ["PluginLoader", "LoadedPlugin", "PluginLoadError", "PluginErrorKind"]
  key_links:
    - from: "src/plugin/loader.rs"
      to: "totui_plugin_interface::PluginModule_Ref"
      via: "load_from_directory()"
      pattern: "PluginModule_Ref::load_from_directory"
    - from: "src/plugin/loader.rs"
      to: "std::panic::catch_unwind"
      via: "FFI boundary protection"
      pattern: "catch_unwind"
---

<objective>
Create the core plugin loading infrastructure with abi_stable integration, panic catching, and session-based disabling for crashed plugins.

Purpose: Enable native plugins to be loaded at runtime while protecting the host from plugin failures and panics.
Output: PluginLoader struct that can load plugins from discovered directories and safely call plugin methods.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-dynamic-loading/08-CONTEXT.md
@.planning/phases/08-dynamic-loading/08-RESEARCH.md
@.planning/phases/07-plugin-manager-core/07-02-SUMMARY.md
@src/plugin/manager.rs
@crates/totui-plugin-interface/src/version.rs
@crates/totui-plugin-interface/src/plugin.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PluginLoader with abi_stable loading and error types</name>
  <files>src/plugin/loader.rs, src/plugin/mod.rs, Cargo.toml</files>
  <action>
Create `src/plugin/loader.rs` with:

1. **Error types** for loading failures:
```rust
pub enum PluginErrorKind {
    VersionMismatch { required: String, actual: String },
    LibraryCorrupted,
    SymbolMissing,
    SessionDisabled,
    Panicked { message: String },
    Other(String),
}

pub struct PluginLoadError {
    pub plugin_name: String,
    pub error_kind: PluginErrorKind,
    pub message: String,
}
```

2. **LoadedPlugin struct** to track loaded plugins (implements proxy pattern):
```rust
pub struct LoadedPlugin {
    /// Plugin trait object with 'static lifetime - this is the proxy pattern.
    /// abi_stable intentionally leaks the library (never unloads) to guarantee
    /// the library outlives all plugin objects, avoiding TLS destructor issues.
    /// See: https://github.com/rust-lang/rust/issues/59629
    pub plugin: Plugin_TO<'static, RBox<()>>,
    pub name: String,
    /// Disabled for current session only (after runtime panic).
    /// Loading failures do NOT set this - they persist across launches.
    pub session_disabled: bool,
}
```

3. **PluginLoader struct** with methods:
   - `new() -> Self` - create empty loader
   - `load_all(&mut self, manager: &PluginManager) -> Vec<PluginLoadError>` - load all enabled plugins, return errors
   - `load_plugin(&self, path: &Path, manifest: &PluginManifest) -> Result<LoadedPlugin, PluginLoadError>` - load single plugin
   - `get(&self, name: &str) -> Option<&LoadedPlugin>` - get loaded plugin by name (case-insensitive)
   - `get_mut(&mut self, name: &str) -> Option<&mut LoadedPlugin>` - get mutable reference
   - `loaded_plugins(&self) -> impl Iterator<Item = &LoadedPlugin>` - iterate loaded plugins

4. **Loading logic** in `load_plugin` (proxy pattern via abi_stable's library leaking):
   - Use `PluginModule_Ref::load_from_directory(path)` from abi_stable
   - abi_stable leaks the library intentionally (never unloads) - this IS the proxy pattern
   - The 'static lifetime on Plugin_TO guarantees the library outlives the plugin object
   - Call `(module.create_plugin())()` to instantiate
   - Map LibraryError variants to PluginErrorKind (OpenError -> LibraryCorrupted, GetSymbolError -> SymbolMissing, IncompatibleVersionNumber -> VersionMismatch)
   - Store in HashMap keyed by lowercase name

5. **Error message formatting** per CONTEXT.md:
   - Version mismatch: "Plugin X requires to-tui 2.1+, you have 2.0"
   - Corrupted/missing symbols: "Plugin X failed to load - may be corrupted or incompatible"

Update `src/plugin/mod.rs`:
- Add `pub mod loader;`
- Add re-exports: `pub use loader::{LoadedPlugin, PluginLoader, PluginLoadError, PluginErrorKind};`

Add to `Cargo.toml`:
- `tracing-appender = "0.2"` for panic logging (will use in next task)
  </action>
  <verify>
`cargo build` compiles without errors.
`cargo test --lib` passes.
  </verify>
  <done>
PluginLoader struct exists with load_all(), load_plugin(), get() methods.
Error types capture version mismatch vs corruption cases.
PluginModule_Ref::load_from_directory used for loading.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add panic-safe plugin calling with session disabling</name>
  <files>src/plugin/loader.rs</files>
  <action>
Add panic catching and session disable functionality to `src/plugin/loader.rs`:

1. **Add call_safely method** to PluginLoader:
```rust
pub fn call_safely<T, F>(&mut self, plugin_name: &str, f: F) -> Result<T, PluginLoadError>
where
    F: FnOnce(&Plugin_TO<'_, RBox<()>>) -> T,
{
    let plugin = self.get(plugin_name).ok_or_else(|| PluginLoadError {
        plugin_name: plugin_name.to_string(),
        error_kind: PluginErrorKind::Other("Plugin not loaded".to_string()),
        message: format!("Plugin {} is not loaded", plugin_name),
    })?;

    if plugin.session_disabled {
        return Err(PluginLoadError {
            plugin_name: plugin_name.to_string(),
            error_kind: PluginErrorKind::SessionDisabled,
            message: format!("Plugin {} is disabled for this session after a previous error", plugin_name),
        });
    }

    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        f(&plugin.plugin)
    }));

    match result {
        Ok(value) => Ok(value),
        Err(panic_info) => {
            // Extract panic message
            let msg = if let Some(s) = panic_info.downcast_ref::<&str>() {
                s.to_string()
            } else if let Some(s) = panic_info.downcast_ref::<String>() {
                s.clone()
            } else {
                "Unknown panic".to_string()
            };

            // Log panic to file (always, per CONTEXT.md)
            Self::log_plugin_panic(plugin_name, &msg);

            // Disable plugin for session (per CONTEXT.md)
            if let Some(p) = self.get_mut(plugin_name) {
                p.session_disabled = true;
            }

            Err(PluginLoadError {
                plugin_name: plugin_name.to_string(),
                error_kind: PluginErrorKind::Panicked { message: msg.clone() },
                message: format!("Plugin {} panicked: {}", plugin_name, msg),
            })
        }
    }
}
```

2. **Add panic logging function** (private):
```rust
fn log_plugin_panic(plugin_name: &str, message: &str) {
    // Get backtrace
    let backtrace = std::backtrace::Backtrace::force_capture();

    // Log using tracing (will be captured by file appender when configured)
    tracing::error!(
        plugin = %plugin_name,
        message = %message,
        backtrace = %backtrace,
        "Plugin panicked during execution"
    );
}
```

3. **Add helper method** for calling generate safely:
```rust
pub fn call_generate(
    &mut self,
    plugin_name: &str,
    input: &str,
) -> Result<Vec<crate::todo::TodoItem>, PluginLoadError> {
    use abi_stable::std_types::RString;
    use crate::plugin::ffi_convert::from_ffi_items;

    self.call_safely(plugin_name, |plugin| {
        let ffi_result = plugin.generate(RString::from(input));
        match ffi_result.into_result() {
            Ok(items) => Ok(from_ffi_items(items)),
            Err(err) => Err(err.to_string()),
        }
    })?
    .map_err(|e| PluginLoadError {
        plugin_name: plugin_name.to_string(),
        error_kind: PluginErrorKind::Other(e.clone()),
        message: e,
    })
}
```

4. **Add unit tests** for panic handling and session disabling.
  </action>
  <verify>
`cargo build` compiles without errors.
`cargo test --lib` passes including new panic handling tests.
  </verify>
  <done>
call_safely() catches panics and disables plugin for session.
log_plugin_panic() logs with backtrace.
call_generate() provides convenient wrapper for generate() calls.
Session-disabled plugins return SessionDisabled error on subsequent calls.
  </done>
</task>

</tasks>

<verification>
Run all verification commands:
```bash
cargo build
cargo test --lib
cargo clippy -- -D warnings
```

All commands should pass with no errors or warnings.
</verification>

<success_criteria>
1. PluginLoader can load plugins via abi_stable's load_from_directory
2. Loading errors are categorized (VersionMismatch vs LibraryCorrupted)
3. call_safely() catches panics and returns error
4. Panicked plugins are disabled for session (session_disabled = true)
5. Panic backtraces are logged via tracing
6. Error messages follow CONTEXT.md patterns
</success_criteria>

<output>
After completion, create `.planning/phases/08-dynamic-loading/08-01-SUMMARY.md`
</output>
