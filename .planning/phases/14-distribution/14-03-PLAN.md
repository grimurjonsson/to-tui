---
phase: 14-distribution
plan: 03
type: execute
wave: 3
depends_on: ["14-01", "14-02"]
files_modified:
  - src/plugin/marketplace.rs
  - src/plugin/manager.rs
  - src/plugin/mod.rs
  - src/plugin/installer.rs
  - src/config.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "Plugin list command shows name, version, status, and source"
    - "Marketplace manifest can be fetched and parsed from GitHub"
    - "Default marketplace configurable in config.toml"
    - "Install without --version fetches latest from marketplace"
  artifacts:
    - path: "src/plugin/marketplace.rs"
      provides: "MarketplaceManifest parsing and PluginEntry struct"
      exports: ["MarketplaceManifest", "PluginEntry", "fetch_marketplace"]
    - path: "src/plugin/manager.rs"
      provides: "Extended PluginInfo with source tracking"
      contains: "source:"
  key_links:
    - from: "src/plugin/installer.rs"
      to: "src/plugin/marketplace.rs"
      via: "resolve_latest_version using fetch_marketplace"
      pattern: "fetch_marketplace"
---

<objective>
Implement marketplace support, source tracking, and enhanced plugin list.

Purpose: Complete the distribution phase by adding marketplace manifest support for version lookup, source tracking for installed plugins, and a configurable default registry.

Output: Marketplace parsing with fetch capability, enhanced `plugin list` with source column, configurable default marketplace, and automatic latest version resolution when --version not specified.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-distribution/14-CONTEXT.md
@.planning/phases/14-distribution/14-RESEARCH.md
@.planning/phases/14-distribution/14-01-SUMMARY.md

@src/plugin/manager.rs
@src/config.rs
@src/cli.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create marketplace module with manifest parsing</name>
  <files>src/plugin/marketplace.rs, src/plugin/mod.rs</files>
  <action>
Create new file `src/plugin/marketplace.rs`:

```rust
//! Marketplace manifest parsing for plugin registries.
//!
//! A marketplace is a GitHub repository containing a marketplace.toml
//! at its root, listing available plugins with metadata.

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};

/// Default marketplace repository
pub const DEFAULT_MARKETPLACE: &str = "grimurjonsson/to-tui-plugins";

/// A plugin entry in the marketplace manifest
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginEntry {
    /// Plugin name (matches directory name in plugins/)
    pub name: String,
    /// Human-readable description
    pub description: String,
    /// Latest available version
    pub version: String,
    /// Repository URL (defaults to marketplace repo)
    #[serde(default)]
    pub repository: Option<String>,
}

/// Marketplace manifest (marketplace.toml)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketplaceManifest {
    /// Marketplace metadata
    pub marketplace: MarketplaceInfo,
    /// Available plugins
    #[serde(default)]
    pub plugins: Vec<PluginEntry>,
}

/// Marketplace metadata section
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketplaceInfo {
    /// Marketplace name
    pub name: String,
    /// Description
    pub description: String,
    /// Repository URL
    #[serde(default)]
    pub url: Option<String>,
}

impl MarketplaceManifest {
    /// Parse marketplace manifest from TOML string
    pub fn parse(content: &str) -> Result<Self> {
        toml::from_str(content)
            .context("Failed to parse marketplace.toml")
    }

    /// Find a plugin by name
    pub fn find_plugin(&self, name: &str) -> Option<&PluginEntry> {
        self.plugins.iter().find(|p| p.name.eq_ignore_ascii_case(name))
    }
}

/// Fetch marketplace manifest from GitHub (raw content URL)
pub fn fetch_marketplace(owner: &str, repo: &str) -> Result<MarketplaceManifest> {
    let url = format!(
        "https://raw.githubusercontent.com/{}/{}/main/marketplace.toml",
        owner, repo
    );

    let client = reqwest::blocking::Client::builder()
        .user_agent("to-tui")
        .build()?;

    let response = client.get(&url).send()?;

    if !response.status().is_success() {
        anyhow::bail!(
            "Failed to fetch marketplace manifest from {}/{}: HTTP {}",
            owner, repo, response.status()
        );
    }

    let content = response.text()?;
    MarketplaceManifest::parse(&content)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_marketplace_manifest() {
        let toml = r#"
[marketplace]
name = "to-tui-plugins"
description = "Official plugin registry"
url = "https://github.com/grimurjonsson/to-tui-plugins"

[[plugins]]
name = "jira"
description = "Fetch Jira tickets as todos"
version = "1.0.0"

[[plugins]]
name = "github"
description = "GitHub issues integration"
version = "0.2.0"
repository = "https://github.com/other/repo"
"#;
        let manifest = MarketplaceManifest::parse(toml).unwrap();
        assert_eq!(manifest.marketplace.name, "to-tui-plugins");
        assert_eq!(manifest.plugins.len(), 2);
        assert_eq!(manifest.plugins[0].name, "jira");
        assert_eq!(manifest.plugins[0].version, "1.0.0");
        assert!(manifest.plugins[0].repository.is_none());
        assert!(manifest.plugins[1].repository.is_some());
    }

    #[test]
    fn test_find_plugin_case_insensitive() {
        let toml = r#"
[marketplace]
name = "test"
description = "test"

[[plugins]]
name = "Jira"
description = "Test"
version = "1.0.0"
"#;
        let manifest = MarketplaceManifest::parse(toml).unwrap();
        assert!(manifest.find_plugin("jira").is_some());
        assert!(manifest.find_plugin("JIRA").is_some());
        assert!(manifest.find_plugin("Jira").is_some());
    }
}
```

Export from mod.rs: `pub mod marketplace;`
  </action>
  <verify>
Run `cargo test --lib -- marketplace` to verify parsing tests pass.
  </verify>
  <done>
Marketplace module exists with MarketplaceManifest struct and fetch_marketplace function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add source tracking to PluginInfo and manager</name>
  <files>src/plugin/manager.rs, src/plugin/installer.rs</files>
  <action>
**Note:** The base `plugin list` command already exists from Phase 7 (Plan 07-03). This task adds source tracking capability.

1. **Add PluginSource enum and source field to PluginInfo** in `src/plugin/manager.rs`:

```rust
/// Source of plugin installation
#[derive(Debug, Clone, Default)]
pub enum PluginSource {
    #[default]
    Unknown,
    Local,
    Remote { owner: String, repo: String },
}

impl std::fmt::Display for PluginSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PluginSource::Unknown => write!(f, "unknown"),
            PluginSource::Local => write!(f, "local"),
            PluginSource::Remote { owner, repo } => write!(f, "{}/{}", owner, repo),
        }
    }
}

// Add to PluginInfo struct:
pub struct PluginInfo {
    // ... existing fields ...
    /// Source of the plugin (local, remote marketplace, unknown)
    pub source: PluginSource,
}
```

2. **Read source from .source file in load_plugin_info**:
```rust
// At end of load_plugin_info, before returning PluginInfo:
let source = {
    let source_file = plugin_dir.join(".source");
    if let Ok(content) = std::fs::read_to_string(&source_file) {
        let content = content.trim();
        if content == "local" {
            PluginSource::Local
        } else if let Some((owner, repo)) = content.split_once('/') {
            PluginSource::Remote { owner: owner.to_string(), repo: repo.to_string() }
        } else {
            PluginSource::Unknown
        }
    } else {
        PluginSource::Unknown
    }
};
```

Initialize source as PluginSource::Unknown for discovered plugins that were installed before source tracking.

3. **Update PluginInstaller** in `src/plugin/installer.rs` to write .source file after installation:

In both `install_from_local` and `install_from_remote`, after successful install:
```rust
// Write source file for tracking
let source_file = target_dir.join(".source");
let source_content = if source.is_local() {
    "local"
} else {
    &format!("{}/{}", source.owner.as_ref().unwrap(), source.repo.as_ref().unwrap())
};
std::fs::write(&source_file, source_content).ok(); // Non-fatal if fails
```
  </action>
  <verify>
Run `cargo test` to verify all tests pass.
  </verify>
  <done>
PluginInfo includes source field. Source tracking persists via .source file in plugin directory, written by installer and read by manager.
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance list command output with source column</name>
  <files>src/main.rs</files>
  <action>
**Requirement coverage:** DIST-04 (Plugin list command showing installed plugins) is already implemented in Phase 7 Plan 07-03. This task enhances the output to include the source column as required by the success criteria.

Update the existing List command handler in `src/main.rs` to show source:

```rust
PluginCommand::List => {
    let manager = PluginManager::discover()?;
    let plugins = manager.list();

    if plugins.is_empty() {
        println!("No plugins installed.");
        println!("\nInstall plugins with: totui plugin install <source>");
        return Ok(());
    }

    // Print header
    println!("{:<20} {:<12} {:<12} {}", "NAME", "VERSION", "STATUS", "SOURCE");
    println!("{}", "-".repeat(60));

    for info in plugins {
        let status = if info.error.is_some() {
            "error"
        } else if !info.available {
            "incompatible"
        } else if !info.enabled {
            "disabled"
        } else {
            "enabled"
        };

        println!("{:<20} {:<12} {:<12} {}",
            info.manifest.name,
            info.manifest.version,
            status,
            info.source
        );
    }
    Ok(())
}
```
  </action>
  <verify>
Run `cargo run -- plugin list` to verify formatted output with NAME, VERSION, STATUS, SOURCE columns.
  </verify>
  <done>
Plugin list command shows name, version, status, and source columns. Base functionality from Phase 7, source column added here.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add default marketplace config</name>
  <files>src/config.rs</files>
  <action>
Add marketplace configuration to Config:

```rust
use crate::plugin::marketplace::DEFAULT_MARKETPLACE;

/// Marketplace configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketplacesConfig {
    /// Default marketplace for short plugin names (owner/repo format)
    #[serde(default = "default_marketplace")]
    pub default: String,
}

fn default_marketplace() -> String {
    DEFAULT_MARKETPLACE.to_string()
}

impl Default for MarketplacesConfig {
    fn default() -> Self {
        Self {
            default: default_marketplace(),
        }
    }
}

// Add to Config struct:
#[serde(default)]
pub marketplaces: MarketplacesConfig,
```

Update Config::default() to include marketplaces: MarketplacesConfig::default().

This allows users to change the default marketplace in config.toml:
```toml
[marketplaces]
default = "myorg/my-plugins"
```
  </action>
  <verify>
Run `cargo test` to verify config serialization tests pass.
  </verify>
  <done>
Default marketplace is configurable in config.toml under [marketplaces] section, defaulting to grimurjonsson/to-tui-plugins.
  </done>
</task>

<task type="auto">
  <name>Task 5: Wire marketplace for latest version lookup</name>
  <files>src/plugin/installer.rs, src/main.rs</files>
  <action>
Wire the marketplace fetch to resolve latest version when `--version` is not specified. This implements the CONTEXT.md decision: "Latest version by default; --version flag for specific version".

1. **Add resolve_latest_version helper** in `src/plugin/installer.rs`:

```rust
use crate::plugin::marketplace::fetch_marketplace;

/// Resolve the latest version for a plugin from its marketplace
pub fn resolve_latest_version(source: &PluginSource) -> Result<String> {
    let owner = source.owner.as_ref()
        .ok_or_else(|| anyhow::anyhow!("Cannot resolve version for local install"))?;
    let repo = source.repo.as_ref()
        .ok_or_else(|| anyhow::anyhow!("Cannot resolve version for local install"))?;

    println!("Fetching marketplace manifest...");
    let manifest = fetch_marketplace(owner, repo)?;

    let entry = manifest.find_plugin(&source.plugin_name)
        .ok_or_else(|| anyhow::anyhow!(
            "Plugin '{}' not found in marketplace {}/{}.\n\
             Use 'totui marketplace search {}' to find available plugins.",
            source.plugin_name, owner, repo, source.plugin_name
        ))?;

    Ok(entry.version.clone())
}
```

2. **Update install handler** in `src/main.rs` to call resolve_latest_version when no version specified:

```rust
PluginCommand::Install { source, version, force } => {
    let mut plugin_source = PluginSource::parse(&source)?;

    // Apply version from CLI arg, or resolve from marketplace
    if let Some(v) = version {
        plugin_source.version = Some(v);
    }

    if plugin_source.is_local() {
        let result = PluginInstaller::install_from_local(
            plugin_source.local_path.as_ref().unwrap(),
            force
        )?;
        println!("Installed plugin '{}' v{}", result.plugin_name, result.version);
    } else {
        // Resolve latest version if not specified
        if plugin_source.version.is_none() {
            let latest = PluginInstaller::resolve_latest_version(&plugin_source)?;
            println!("Resolved latest version: {}", latest);
            plugin_source.version = Some(latest);
        }

        let result = PluginInstaller::install_from_remote(&plugin_source, force)?;
        println!("Installed plugin '{}' v{}", result.plugin_name, result.version);
    }
    Ok(())
}
```

Import `PluginInstaller::resolve_latest_version` in main.rs.
  </action>
  <verify>
Run `cargo check` to verify compilation.
Run `cargo test` to verify all tests pass.
  </verify>
  <done>
Install command fetches latest version from marketplace when --version not specified. Explicit --version still works for specific versions.
  </done>
</task>

</tasks>

<verification>
1. `cargo test` - All tests pass including new marketplace tests
2. `cargo clippy` - No new warnings
3. Manual test: Install a plugin locally, run `plugin list`, verify source shows "local"
4. Manual test: Check config.toml serialization includes [marketplaces] section
5. Verify marketplace.toml schema matches RESEARCH.md specification
</verification>

<success_criteria>
- MarketplaceManifest parses marketplace.toml format correctly
- fetch_marketplace retrieves manifest from GitHub raw URL
- PluginInfo includes source field tracking where plugin came from
- `plugin list` command shows columns: name, version, status, source
- Default marketplace configurable in config.toml
- Source tracking persists across app restarts via .source file
- Install without --version fetches latest from marketplace manifest
- All tests pass, no clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/14-distribution/14-03-SUMMARY.md`
</output>
