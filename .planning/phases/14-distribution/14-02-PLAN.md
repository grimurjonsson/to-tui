---
phase: 14-distribution
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/plugin/installer.rs
  - src/utils/upgrade.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "Remote plugin downloads from GitHub release URL succeed"
    - "Downloaded archive extracts and installs to plugins directory"
    - "Progress output shows step-by-step status during download"
    - "Missing platform binary fails with clear error listing available platforms"
  artifacts:
    - path: "src/plugin/installer.rs"
      provides: "install_from_remote method for GitHub downloads"
      exports: ["install_from_remote", "get_plugin_download_url"]
  key_links:
    - from: "src/plugin/installer.rs"
      to: "src/utils/upgrade.rs"
      via: "reuse download_file_blocking, get_target_triple patterns"
      pattern: "get_target_triple|download_file_blocking"
---

<objective>
Implement GitHub-based plugin installation with progress reporting.

Purpose: Enable users to install plugins directly from GitHub releases using the explicit path format (owner/repo/plugin-name), completing the distribution system.

Output: Remote installation support in PluginInstaller that downloads, extracts, validates, and installs plugin binaries from GitHub releases.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-distribution/14-CONTEXT.md
@.planning/phases/14-distribution/14-RESEARCH.md
@.planning/phases/14-distribution/14-01-SUMMARY.md

@src/plugin/installer.rs
@src/utils/upgrade.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add remote installation to PluginInstaller</name>
  <files>src/plugin/installer.rs, src/utils/upgrade.rs</files>
  <action>
1. **Refactor get_target_triple to be reusable** - In `src/utils/upgrade.rs`, make `get_target_triple()` public:
```rust
pub fn get_target_triple() -> &'static str { ... }
```

2. **Add remote install method** to PluginInstaller in `src/plugin/installer.rs`:

```rust
use crate::utils::upgrade::get_target_triple;
use flate2::read::GzDecoder;
use tar::Archive;
use tempfile::tempdir;

/// Download URL format for plugin releases
/// https://github.com/{owner}/{repo}/releases/download/v{version}/{plugin}-{target}.tar.gz
fn get_plugin_download_url(source: &PluginSource) -> Result<String> {
    let target = get_target_triple();
    let version = source.version.as_ref()
        .ok_or_else(|| anyhow::anyhow!("Version required for remote install"))?;
    Ok(format!(
        "https://github.com/{}/{}/releases/download/v{}/{}-{}.tar.gz",
        source.owner.as_ref().unwrap(),
        source.repo.as_ref().unwrap(),
        version,
        source.plugin_name,
        target
    ))
}

/// Install plugin from remote GitHub release
pub fn install_from_remote(source: &PluginSource, force: bool) -> Result<InstallResult> {
    // 1. Determine version (version is required here - latest lookup added in 14-03)
    let version = source.version.as_ref()
        .ok_or_else(|| anyhow::anyhow!(
            "Version required. Use --version to specify (e.g., --version 1.0.0)\n\
             Example: totui plugin install grimurjonsson/to-tui-plugins/jira --version 1.0.0"
        ))?;

    // 2. Construct download URL
    let url = get_plugin_download_url(source)?;
    println!("Downloading from: {}", url);

    // 3. Download to temp directory
    let temp_dir = tempdir().context("Failed to create temp directory")?;
    let archive_path = temp_dir.path().join("plugin.tar.gz");

    println!("Downloading...");
    download_plugin_blocking(&url, &archive_path)?;
    println!("Download complete.");

    // 4. Extract archive
    println!("Extracting...");
    let extracted_dir = extract_plugin_archive(&archive_path, temp_dir.path())?;
    println!("Extraction complete.");

    // 5. Validate manifest
    println!("Verifying...");
    let info = PluginManager::load_plugin_info(&extracted_dir);
    if let Some(err) = &info.error {
        anyhow::bail!("Invalid plugin: {}", err);
    }
    if !info.available {
        if let Some(reason) = &info.availability_reason {
            anyhow::bail!("Plugin not compatible: {}", reason);
        }
    }

    // 6. Check for existing installation
    let plugins_dir = get_plugins_dir()?;
    let target_dir = plugins_dir.join(&source.plugin_name);
    if target_dir.exists() && !force {
        anyhow::bail!(
            "Plugin '{}' already installed at {:?}. Use --force to overwrite.",
            source.plugin_name, target_dir
        );
    }

    // 7. Move to plugins directory
    println!("Installing...");
    if target_dir.exists() {
        std::fs::remove_dir_all(&target_dir)
            .context("Failed to remove existing plugin")?;
    }
    std::fs::create_dir_all(&plugins_dir)?;
    std::fs::rename(&extracted_dir, &target_dir)
        .or_else(|_| {
            // rename across filesystems fails, fall back to copy
            copy_dir_recursive(&extracted_dir, &target_dir)?;
            std::fs::remove_dir_all(&extracted_dir)?;
            Ok::<(), anyhow::Error>(())
        })?;

    println!("Done!");

    Ok(InstallResult {
        plugin_name: info.manifest.name,
        version: info.manifest.version,
        path: target_dir,
    })
}

/// Download plugin archive (blocking, no progress channel for simplicity)
fn download_plugin_blocking(url: &str, target_path: &Path) -> Result<()> {
    let client = reqwest::blocking::Client::builder()
        .user_agent("to-tui")
        .build()?;

    let response = client
        .get(url)
        .header("Accept", "application/octet-stream")
        .send()?;

    let status = response.status();
    if status == reqwest::StatusCode::NOT_FOUND {
        let target = get_target_triple();
        anyhow::bail!(
            "Plugin binary not found for platform '{}'.\n\
             The plugin may not be built for your platform.\n\
             Check the release page for available platforms.",
            target
        );
    }
    if !status.is_success() {
        anyhow::bail!("HTTP error: {} {}", status.as_u16(),
            status.canonical_reason().unwrap_or("Unknown"));
    }

    let bytes = response.bytes()?;
    std::fs::write(target_path, &bytes)?;
    Ok(())
}

/// Extract tar.gz archive to target directory
fn extract_plugin_archive(archive_path: &Path, target_dir: &Path) -> Result<PathBuf> {
    let tar_gz = std::fs::File::open(archive_path)
        .context("Failed to open archive")?;
    let tar = GzDecoder::new(tar_gz);
    let mut archive = Archive::new(tar);

    let extracted_dir = target_dir.join("extracted");
    std::fs::create_dir_all(&extracted_dir)?;
    archive.unpack(&extracted_dir)
        .context("Failed to extract archive")?;

    // Find the plugin directory (may be nested one level)
    let entries: Vec<_> = std::fs::read_dir(&extracted_dir)?
        .filter_map(|e| e.ok())
        .collect();

    // If there's exactly one directory, use that as the plugin root
    if entries.len() == 1 && entries[0].path().is_dir() {
        Ok(entries[0].path())
    } else {
        Ok(extracted_dir)
    }
}
```

Key patterns from RESEARCH.md:
- Use existing get_target_triple() from upgrade.rs
- Download to temp, validate, then move
- 404 response -> clear message about platform availability
- Step-by-step progress output (Downloading... Verifying... Installing... Done!)
  </action>
  <verify>
Run `cargo check` to verify compilation.
Run `cargo test` to ensure all tests pass.
  </verify>
  <done>
Remote installation method exists that downloads plugin archives from GitHub releases, extracts and validates them, and installs to the plugins directory.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire remote install path in main.rs</name>
  <files>src/main.rs</files>
  <action>
Update the Install command handler in main.rs to handle remote sources:

```rust
PluginCommand::Install { source, version, force } => {
    let mut plugin_source = PluginSource::parse(&source)?;

    // Apply version from CLI arg
    if version.is_some() {
        plugin_source.version = version;
    }

    if plugin_source.is_local() {
        let result = PluginInstaller::install_from_local(
            plugin_source.local_path.as_ref().unwrap(),
            force
        )?;
        println!("Installed plugin '{}' v{}", result.plugin_name, result.version);
    } else {
        let result = PluginInstaller::install_from_remote(&plugin_source, force)?;
        println!("Installed plugin '{}' v{}", result.plugin_name, result.version);
    }
    Ok(())
}
```

The remote path is detected by PluginSource::parse when the source contains two slashes (owner/repo/plugin format) rather than being an existing filesystem path.
  </action>
  <verify>
Run `cargo build` to verify compilation.
  </verify>
  <done>
CLI `totui plugin install owner/repo/plugin --version X.Y.Z` attempts remote installation from GitHub releases.
  </done>
</task>

</tasks>

<verification>
1. `cargo test` - All existing tests still pass
2. `cargo clippy` - No new warnings
3. Manual test (if test plugin available): `cargo run -- plugin install grimurjonsson/to-tui-plugins/test --version 1.0.0`
4. Manual test: Try URL that doesn't exist, verify clear error message about platform
5. Manual test: Verify progress output shows Downloading/Verifying/Installing/Done steps
</verification>

<success_criteria>
- get_target_triple() is public and reusable from upgrade.rs
- Remote installation downloads from correct GitHub release URL format
- Tar.gz archives extract correctly
- Missing platform binaries produce clear error messages
- Progress output shows step-by-step status
- Version compatibility checked before installation
- Existing plugin detection works with --force override
</success_criteria>

<output>
After completion, create `.planning/phases/14-distribution/14-02-SUMMARY.md`
</output>
