---
phase: 05-automatic-self-upgrade
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - src/ui/components/mod.rs
  - src/utils/upgrade.rs
  - src/app/event.rs
autonomous: false

must_haves:
  truths:
    - "Progress bar shows download progress in TUI"
    - "Error state shows message with retry/dismiss options"
    - "Restart prompt shows after successful download"
    - "Y at restart prompt replaces binary and relaunches"
  artifacts:
    - path: "src/ui/components/mod.rs"
      provides: "Rendered progress bar, error message, restart prompt"
      contains: "Gauge"
    - path: "src/utils/upgrade.rs"
      provides: "extract_binary and replace_and_restart functions"
      exports: ["extract_binary", "replace_and_restart"]
  key_links:
    - from: "src/ui/components/mod.rs"
      to: "src/utils/upgrade.rs"
      via: "imports format_bytes for display"
      pattern: "format_bytes"
    - from: "src/app/event.rs"
      to: "src/utils/upgrade.rs"
      via: "calls extract_binary, replace_and_restart"
      pattern: "extract_binary|replace_and_restart"
---

<objective>
Complete the upgrade UI and binary replacement functionality.

Purpose: Implement the visual feedback during download and the actual binary replacement and restart logic.
Output: Full upgrade workflow working end-to-end with progress bar, error handling, and restart.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-automatic-self-upgrade/05-RESEARCH.md
@.planning/phases/05-automatic-self-upgrade/05-01-SUMMARY.md
@.planning/phases/05-automatic-self-upgrade/05-02-SUMMARY.md

# Files to modify
@src/ui/components/mod.rs
@src/utils/upgrade.rs
@src/app/event.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update render_upgrade_overlay for all sub-states</name>
  <files>src/ui/components/mod.rs</files>
  <action>
1. Add import: `use crate::utils::upgrade::{UpgradeSubState, format_bytes};`
2. Add import: `use ratatui::widgets::Gauge;`

3. Rewrite `render_upgrade_overlay()` to handle all sub-states:

```rust
fn render_upgrade_overlay(f: &mut Frame, state: &AppState) {
    if state.new_version_available.is_none() {
        return;
    }

    let sub_state = state.upgrade_sub_state.as_ref();

    match sub_state {
        Some(UpgradeSubState::Downloading { progress, bytes_downloaded, total_bytes }) => {
            render_upgrade_downloading(f, state, *progress, *bytes_downloaded, *total_bytes);
        }
        Some(UpgradeSubState::Error { message }) => {
            render_upgrade_error(f, state, message);
        }
        Some(UpgradeSubState::RestartPrompt { downloaded_path: _ }) => {
            render_upgrade_restart_prompt(f, state);
        }
        Some(UpgradeSubState::Prompt) | None => {
            render_upgrade_prompt(f, state);
        }
    }
}
```

4. Extract current prompt rendering to `render_upgrade_prompt(f, state)` - keep existing implementation.

5. Add `render_upgrade_downloading(f, state, progress, bytes_downloaded, total_bytes)`:
   - Use centered_rect(50, 25, f.area()) for a compact modal
   - Title: " Downloading Update "
   - Show current version -> new version
   - Use ratatui `Gauge` widget:
     - percent: `(progress * 100.0) as u16`
     - label: format!("{} / {}", format_bytes(bytes_downloaded), total_bytes.map(format_bytes).unwrap_or("???".to_string()))
     - style: cyan foreground on dark gray background
   - Footer: "[Esc] Cancel"

6. Add `render_upgrade_error(f, state, message)`:
   - Use centered_rect(60, 30, f.area())
   - Title: " Download Error " with red border
   - Show error message in red text
   - Footer: "[R]etry  [Esc] Dismiss"

7. Add `render_upgrade_restart_prompt(f, state)`:
   - Use centered_rect(55, 35, f.area())
   - Title: " Update Ready "
   - Content:
     - "Download complete!"
     - ""
     - "The application will restart to complete the update."
     - ""
     - "Any unsaved changes will be lost."
   - Footer: "[Y]es - Restart now  [N]o - Later"
  </action>
  <verify>`cargo check` passes. Run the TUI and trigger upgrade modal to see rendering (if version available).</verify>
  <done>
- render_upgrade_overlay dispatches to sub-state specific renderers
- Downloading state shows progress bar with byte counts
- Error state shows message with retry/dismiss options
- RestartPrompt state shows confirmation dialog
  </done>
</task>

<task type="auto">
  <name>Task 2: Add binary extraction and restart functions</name>
  <files>src/utils/upgrade.rs</files>
  <action>
1. Add imports:
   - `use self_update::Extract;`
   - `use std::path::Path;`
   - `use tempfile::TempDir;`

2. Add `extract_binary(archive_path: &Path) -> anyhow::Result<PathBuf>`:
   - Create temp directory using `tempfile::tempdir()?`
   - Extract using self_update::Extract:
     ```rust
     Extract::from_source(archive_path)
         .archive(self_update::ArchiveKind::Tar(Some(self_update::Compression::Gz)))
         .extract_into(temp_dir.path())?;
     ```
   - Find the `totui` binary in extracted files (it should be at temp_dir/totui)
   - **IMPORTANT - Tempdir lifetime fix:** The tempdir will be deleted when it goes out of scope. To prevent this, copy the extracted binary to a stable temp location BEFORE returning:
     ```rust
     // Create a stable path that won't be cleaned up when tempdir drops
     let stable_binary_path = std::env::temp_dir().join("totui-upgrade-binary");
     std::fs::copy(&extracted_binary_path, &stable_binary_path)
         .with_context(|| "Failed to copy extracted binary to stable location")?;

     // Set executable permissions on the stable copy
     #[cfg(unix)]
     {
         use std::os::unix::fs::PermissionsExt;
         std::fs::set_permissions(&stable_binary_path, std::fs::Permissions::from_mode(0o755))?;
     }

     // tempdir drops here and cleans up extraction directory, but our copy is safe
     Ok(stable_binary_path)
     ```
   - This approach keeps the temp extraction directory managed (auto-cleanup) while preserving the binary we need.

3. Add `replace_and_restart(new_binary_path: &Path) -> anyhow::Result<()>`:
   - First check we can write to current exe location:
     ```rust
     let current_exe = std::env::current_exe()?;
     // Try to get parent dir and check write permission
     ```
   - Use self_replace::self_replace() for atomic replacement:
     ```rust
     self_replace::self_replace(new_binary_path)
         .context("Failed to replace binary")?;
     ```
   - After replacement, restart:
     ```rust
     #[cfg(unix)]
     {
         use std::os::unix::process::CommandExt;
         let args: Vec<String> = std::env::args().skip(1).collect();
         let err = std::process::Command::new(&current_exe)
             .args(&args)
             .exec();
         // exec() only returns on error
         anyhow::bail!("Failed to restart: {}", err);
     }

     #[cfg(not(unix))]
     {
         // On Windows, spawn new process and exit
         let args: Vec<String> = std::env::args().skip(1).collect();
         std::process::Command::new(&current_exe)
             .args(&args)
             .spawn()
             .context("Failed to spawn new process")?;
         std::process::exit(0);
     }
     ```

4. Add `check_write_permission() -> anyhow::Result<()>`:
   - Gets current_exe() path
   - Checks if parent directory is writable
   - Returns error with helpful message if not (e.g., "Binary is in /usr/local/bin which requires sudo. Run: sudo totui --upgrade")
  </action>
  <verify>`cargo check` passes</verify>
  <done>
- extract_binary() can extract totui from tar.gz archive
- Extracted binary is copied to stable temp location before tempdir cleanup
- replace_and_restart() atomically replaces binary and relaunches
- check_write_permission() validates we can write to binary location
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire up restart in event handler</name>
  <files>src/app/event.rs</files>
  <action>
1. Add import: `use crate::utils::upgrade::{extract_binary, replace_and_restart, check_write_permission};`

2. Update the RestartPrompt handler in `handle_upgrade_prompt_mode()`:

```rust
Some(UpgradeSubState::RestartPrompt { downloaded_path }) => {
    match key.code {
        KeyCode::Char('y') | KeyCode::Char('Y') | KeyCode::Enter => {
            // Check write permission first
            if let Err(e) = check_write_permission() {
                state.upgrade_sub_state = Some(UpgradeSubState::Error {
                    message: e.to_string(),
                });
                return Ok(());
            }

            // Extract binary from archive
            match extract_binary(&downloaded_path) {
                Ok(binary_path) => {
                    // Attempt replacement and restart
                    // Note: replace_and_restart will not return on success (exec replaces process)
                    if let Err(e) = replace_and_restart(&binary_path) {
                        state.upgrade_sub_state = Some(UpgradeSubState::Error {
                            message: format!("Upgrade failed: {}", e),
                        });
                    }
                }
                Err(e) => {
                    state.upgrade_sub_state = Some(UpgradeSubState::Error {
                        message: format!("Extraction failed: {}", e),
                    });
                }
            }
        }
        KeyCode::Char('n') | KeyCode::Char('N') | KeyCode::Esc => {
            // Clean up downloaded file
            let _ = std::fs::remove_file(&downloaded_path);
            state.upgrade_sub_state = None;
            state.show_upgrade_prompt = false;
            state.mode = Mode::Navigate;
        }
        _ => {}
    }
}
```

3. Also update the Prompt handler's Y case to check write permission BEFORE starting download:

```rust
KeyCode::Char('y') | KeyCode::Char('Y') | KeyCode::Enter => {
    // Check write permission before downloading
    if let Err(e) = check_write_permission() {
        state.upgrade_sub_state = Some(UpgradeSubState::Error {
            message: e.to_string(),
        });
        return Ok(());
    }
    state.start_download();
}
```

This prevents wasting download time if we can't write anyway.
  </action>
  <verify>`cargo check` passes. `cargo test` passes.</verify>
  <done>
- Y in RestartPrompt extracts binary and calls replace_and_restart
- Permission check happens before download starts
- Errors transition to Error sub-state for user feedback
- N in RestartPrompt cleans up downloaded file
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete automatic self-upgrade workflow: download with progress bar, error handling, binary replacement, and restart</what-built>
  <how-to-verify>
1. Build and run: `cargo build --release && ./target/release/totui`
2. Wait for version check (or manually trigger by simulating new version)
3. When upgrade modal appears, press Y to start download
4. Verify progress bar shows during download
5. When download completes, verify restart prompt appears
6. Press Y to restart - application should restart with new version
7. Test error scenarios:
   - Press Esc during download (should cancel)
   - Test with invalid URL (should show error with retry option)

Note: For testing without an actual newer version, you may need to:
- Temporarily modify version_check.rs to report a fake newer version
- Or create a test release on GitHub
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
- [ ] `cargo check` passes
- [ ] `cargo test` passes
- [ ] Progress bar renders during download
- [ ] Error messages display correctly
- [ ] Restart prompt appears after download
- [ ] Binary replacement works
- [ ] Application restarts successfully
</verification>

<success_criteria>
Full upgrade workflow working end-to-end:
1. Y in modal starts download with progress bar
2. Progress updates show bytes/total during download
3. Download errors show error message with retry option
4. After download, restart prompt appears
5. Y at restart extracts, replaces binary, and relaunches
6. N at restart dismisses without upgrading
7. User can cancel download with Esc
</success_criteria>

<output>
After completion, create `.planning/phases/05-automatic-self-upgrade/05-03-SUMMARY.md`
</output>
