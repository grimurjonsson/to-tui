---
phase: 05-automatic-self-upgrade
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/app/state.rs
  - src/app/event.rs
  - src/ui/mod.rs
autonomous: true

must_haves:
  truths:
    - "Pressing Y in upgrade modal starts download"
    - "Download progress updates are polled in event loop"
    - "State transitions work: Prompt -> Downloading -> RestartPrompt/Error"
  artifacts:
    - path: "src/app/state.rs"
      provides: "AppState with upgrade_sub_state and download receiver"
      contains: "upgrade_sub_state"
    - path: "src/app/event.rs"
      provides: "Event handling for upgrade mode sub-states"
      contains: "UpgradeSubState"
    - path: "src/ui/mod.rs"
      provides: "Event loop polling for download progress"
      contains: "check_download_progress"
  key_links:
    - from: "src/app/state.rs"
      to: "src/utils/upgrade.rs"
      via: "imports UpgradeSubState, spawn_download"
      pattern: "use crate::utils::upgrade"
    - from: "src/app/event.rs"
      to: "src/app/state.rs"
      via: "calls state.start_download(), state.check_download_progress()"
      pattern: "start_download|check_download_progress"
    - from: "src/ui/mod.rs"
      to: "src/app/state.rs"
      via: "event loop tick calls state.check_download_progress()"
      pattern: "check_download_progress"
---

<objective>
Integrate upgrade sub-states into AppState and event handling.

Purpose: Wire up the download flow so pressing Y starts the download and progress updates flow through the event loop.
Output: Modified state.rs with sub-state tracking and event.rs with updated upgrade mode handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-automatic-self-upgrade/05-RESEARCH.md
@.planning/phases/05-automatic-self-upgrade/05-01-SUMMARY.md

# Files to modify
@src/app/state.rs
@src/app/event.rs
@src/ui/mod.rs

# New upgrade module from Plan 01
@src/utils/upgrade.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add upgrade sub-state tracking to AppState</name>
  <files>src/app/state.rs</files>
  <action>
1. Add import: `use crate::utils::upgrade::{UpgradeSubState, DownloadProgress, spawn_download, get_asset_download_url};`

2. Add fields to AppState struct:
   - `pub upgrade_sub_state: Option<UpgradeSubState>` - Current sub-state when in Mode::UpgradePrompt
   - `download_progress_rx: Option<tokio::sync::mpsc::Receiver<DownloadProgress>>` - Channel receiver for download updates

3. Initialize both fields to `None` in `AppState::new()`

4. Update `open_upgrade_modal()` to set `upgrade_sub_state = Some(UpgradeSubState::Prompt)` when opening the modal

5. Update `dismiss_upgrade_session()` to also clear `upgrade_sub_state = None` and `download_progress_rx = None`

6. Add new method `start_download(&mut self)`:
   - Gets version from `self.new_version_available`
   - Constructs download URL using `get_asset_download_url(version)`
   - Creates temp file path in system temp dir (use `std::env::temp_dir().join(format!("totui-{}.tar.gz", version))`)
   - Calls `spawn_download()` and stores receiver in `download_progress_rx`
   - Sets `upgrade_sub_state = Some(UpgradeSubState::Downloading { progress: 0.0, bytes_downloaded: 0, total_bytes: None })`

7. Add new method `check_download_progress(&mut self)`:
   - Returns early if `download_progress_rx` is None
   - Uses `try_recv()` (non-blocking) on the receiver
   - On `DownloadProgress::Progress { bytes, total }`:
     - Update `upgrade_sub_state` Downloading variant fields
     - Calculate progress as `bytes as f64 / total.unwrap_or(bytes) as f64`
   - On `DownloadProgress::Complete { path }`:
     - Set `download_progress_rx = None`
     - Set `upgrade_sub_state = Some(UpgradeSubState::RestartPrompt { downloaded_path: path })`
   - On `DownloadProgress::Error { message }`:
     - Set `download_progress_rx = None`
     - Set `upgrade_sub_state = Some(UpgradeSubState::Error { message })`
   - On `TryRecvError::Empty`: do nothing (no update yet)
   - On `TryRecvError::Disconnected`:
     - Set `download_progress_rx = None`
     - Set `upgrade_sub_state = Some(UpgradeSubState::Error { message: "Download task crashed".to_string() })`
  </action>
  <verify>`cargo check` passes</verify>
  <done>
- AppState has upgrade_sub_state and download_progress_rx fields
- open_upgrade_modal sets sub-state to Prompt
- start_download() initiates download and sets Downloading state
- check_download_progress() polls channel and updates state
  </done>
</task>

<task type="auto">
  <name>Task 2: Update event handling for upgrade mode sub-states</name>
  <files>src/app/event.rs</files>
  <action>
1. Add import: `use crate::utils::upgrade::UpgradeSubState;`

2. Modify `handle_upgrade_prompt_mode()` to handle sub-states:

```rust
fn handle_upgrade_prompt_mode(key: KeyEvent, state: &mut AppState) -> Result<()> {
    let sub_state = state.upgrade_sub_state.clone();

    match sub_state {
        Some(UpgradeSubState::Prompt) | None => {
            // Original prompt behavior with modification for Y
            match key.code {
                KeyCode::Char('y') | KeyCode::Char('Y') | KeyCode::Enter => {
                    // NEW: Start download instead of just setting URL
                    state.start_download();
                }
                KeyCode::Char('n') | KeyCode::Char('N') | KeyCode::Esc => {
                    state.dismiss_upgrade_session();
                }
                KeyCode::Char('s') | KeyCode::Char('S') => {
                    if let Some(version) = state.new_version_available.clone() {
                        state.skip_version_permanently(version)?;
                        state.set_status_message("Skipped version updates".to_string());
                    }
                }
                _ => {}
            }
        }
        Some(UpgradeSubState::Downloading { .. }) => {
            // During download, only allow cancel with Esc
            if key.code == KeyCode::Esc {
                state.download_progress_rx = None;
                state.upgrade_sub_state = None;
                state.show_upgrade_prompt = false;
                state.mode = Mode::Navigate;
            }
            // Otherwise ignore - download continues
        }
        Some(UpgradeSubState::Error { .. }) => {
            match key.code {
                KeyCode::Char('r') | KeyCode::Char('R') | KeyCode::Enter => {
                    // Retry download
                    state.start_download();
                }
                KeyCode::Esc | KeyCode::Char('n') | KeyCode::Char('N') => {
                    // Dismiss error
                    state.upgrade_sub_state = None;
                    state.show_upgrade_prompt = false;
                    state.mode = Mode::Navigate;
                }
                _ => {}
            }
        }
        Some(UpgradeSubState::RestartPrompt { downloaded_path }) => {
            match key.code {
                KeyCode::Char('y') | KeyCode::Char('Y') | KeyCode::Enter => {
                    // Will be implemented in Plan 03: extract, replace, restart
                    // For now, just store the path and note it needs implementation
                    state.set_status_message(format!("Downloaded to: {:?}", downloaded_path));
                    state.upgrade_sub_state = None;
                    state.show_upgrade_prompt = false;
                    state.mode = Mode::Navigate;
                }
                KeyCode::Char('n') | KeyCode::Char('N') | KeyCode::Esc => {
                    // Dismiss without installing
                    state.upgrade_sub_state = None;
                    state.show_upgrade_prompt = false;
                    state.mode = Mode::Navigate;
                }
                _ => {}
            }
        }
    }
    Ok(())
}
```

Note: The Y handler in RestartPrompt is a placeholder - full implementation (extract, replace, restart) comes in Plan 03.
  </action>
  <verify>`cargo check` passes. `cargo test` passes.</verify>
  <done>
- handle_upgrade_prompt_mode handles all four sub-states
- Y in Prompt state starts download
- Esc during download cancels
- R in Error state retries
- Y/N in RestartPrompt works (placeholder for actual restart)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add download progress polling to event loop</name>
  <files>src/ui/mod.rs</files>
  <action>
In `src/ui/mod.rs`, find the `run_app()` function (around line 94-140). In the main loop, right after the existing poll calls (lines 100-103), add a call to poll download progress:

```rust
// Inside the loop, after existing calls:
state.clear_expired_status_message();
state.check_plugin_result();
state.check_version_update();
state.tick_spinner();
state.check_download_progress();  // ADD THIS LINE
```

This ensures download progress is polled on every tick (~100ms) so the UI stays responsive and updates the progress bar smoothly.
  </action>
  <verify>`cargo check` passes. `cargo test` passes.</verify>
  <done>
- check_download_progress() is called in the main event loop tick
- Download progress updates flow through to state every 100ms
  </done>
</task>

</tasks>

<verification>
- [ ] `cargo check` passes
- [ ] `cargo test` passes
- [ ] State transitions compile correctly
- [ ] Event handling covers all sub-states
- [ ] Event loop polls download progress
</verification>

<success_criteria>
Download flow is wired up:
- Y in upgrade modal starts async download
- Progress updates flow from spawn_download through channel to AppState
- Sub-state transitions work: Prompt -> Downloading -> RestartPrompt/Error
- User can cancel download or dismiss error
- Event loop polls check_download_progress() every tick
</success_criteria>

<output>
After completion, create `.planning/phases/05-automatic-self-upgrade/05-02-SUMMARY.md`
</output>
