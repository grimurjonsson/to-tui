---
phase: 10-metadata-database
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/database.rs
  - src/storage/metadata.rs
  - src/storage/mod.rs
autonomous: true

must_haves:
  truths:
    - "Metadata tables exist in database after init_database()"
    - "Can store JSON metadata for a todo item by (todo_id, plugin_name)"
    - "Can retrieve metadata for a todo item (returns {} if not exists)"
    - "Can merge or replace metadata using explicit flag"
    - "Reserved key prefix _ is rejected on set"
  artifacts:
    - path: "src/storage/metadata.rs"
      provides: "Metadata CRUD operations"
      exports: ["set_todo_metadata", "get_todo_metadata", "delete_todo_metadata", "set_project_metadata", "get_project_metadata", "delete_project_metadata"]
    - path: "src/storage/database.rs"
      provides: "Schema initialization for metadata tables"
      contains: "CREATE TABLE IF NOT EXISTS todo_metadata"
  key_links:
    - from: "src/storage/metadata.rs"
      to: "src/storage/database.rs"
      via: "get_connection()"
      pattern: "get_connection\\(\\)"
---

<objective>
Create database schema and storage layer CRUD operations for plugin metadata.

Purpose: Enable metadata persistence at the storage layer before exposing via FFI. This establishes the foundation for plugins to attach custom JSON data to todos and projects.

Output: `todo_metadata` and `project_metadata` tables with CRUD functions in new `src/storage/metadata.rs` module.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-metadata-database/10-CONTEXT.md
@.planning/phases/10-metadata-database/10-RESEARCH.md

@src/storage/database.rs
@src/storage/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add metadata table schema to init_database</name>
  <files>src/storage/database.rs</files>
  <action>
    Add two new tables to `init_database()`:

    1. `todo_metadata` table:
       ```sql
       CREATE TABLE IF NOT EXISTS todo_metadata (
           id TEXT PRIMARY KEY,
           todo_id TEXT NOT NULL,
           plugin_name TEXT NOT NULL,
           data TEXT NOT NULL DEFAULT '{}',
           created_at TEXT NOT NULL,
           updated_at TEXT NOT NULL,
           UNIQUE(todo_id, plugin_name)
       );
       ```

    2. Create indexes:
       - `idx_todo_metadata_todo` on `todo_id`
       - `idx_todo_metadata_plugin` on `plugin_name`

    3. `project_metadata` table:
       ```sql
       CREATE TABLE IF NOT EXISTS project_metadata (
           id TEXT PRIMARY KEY,
           project_name TEXT NOT NULL,
           plugin_name TEXT NOT NULL,
           data TEXT NOT NULL DEFAULT '{}',
           created_at TEXT NOT NULL,
           updated_at TEXT NOT NULL,
           UNIQUE(project_name, plugin_name)
       );
       ```

    4. Create indexes:
       - `idx_project_metadata_project` on `project_name`
       - `idx_project_metadata_plugin` on `plugin_name`

    Use same pattern as existing table creation: `conn.execute(..., [])?;` for CREATE TABLE, then separate execute calls for indexes.
  </action>
  <verify>`cargo build` succeeds; manually verify tables would be created by inspecting init_database code</verify>
  <done>init_database creates todo_metadata and project_metadata tables with appropriate indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create metadata.rs CRUD module</name>
  <files>src/storage/metadata.rs, src/storage/mod.rs</files>
  <action>
    Create new file `src/storage/metadata.rs` with:

    1. Imports:
       ```rust
       use anyhow::{Context, Result};
       use chrono::Utc;
       use rusqlite::params;
       use uuid::Uuid;
       use super::database::get_connection;
       ```

    2. Helper function to validate JSON and check reserved keys:
       ```rust
       fn validate_metadata_json(data: &str) -> Result<()> {
           let value: serde_json::Value = serde_json::from_str(data)
               .with_context(|| format!("Invalid JSON: {}", data))?;

           if let serde_json::Value::Object(map) = &value {
               for key in map.keys() {
                   if key.starts_with('_') {
                       anyhow::bail!("Keys starting with '_' are reserved: {}", key);
                   }
               }
           }
           Ok(())
       }
       ```

    3. `set_todo_metadata(todo_id: &Uuid, plugin_name: &str, data: &str, merge: bool) -> Result<()>`:
       - Call validate_metadata_json
       - Get connection
       - If merge: try UPDATE with `json_patch(data, ?1)`, if 0 rows updated then INSERT
       - If replace: INSERT ... ON CONFLICT DO UPDATE SET data = ?
       - Use RFC3339 for timestamps

    4. `get_todo_metadata(todo_id: &Uuid, plugin_name: &str) -> Result<String>`:
       - Query by todo_id and plugin_name
       - Return "{}" on QueryReturnedNoRows

    5. `delete_todo_metadata(todo_id: &Uuid, plugin_name: &str) -> Result<bool>`:
       - DELETE WHERE todo_id = ? AND plugin_name = ?
       - Return true if deleted, false if not found

    6. `set_project_metadata(project_name: &str, plugin_name: &str, data: &str, merge: bool) -> Result<()>`:
       - Same pattern as set_todo_metadata

    7. `get_project_metadata(project_name: &str, plugin_name: &str) -> Result<String>`:
       - Same pattern as get_todo_metadata

    8. `delete_project_metadata(project_name: &str, plugin_name: &str) -> Result<bool>`:
       - Same pattern as delete_todo_metadata

    Then add `pub mod metadata;` to `src/storage/mod.rs`.
  </action>
  <verify>`cargo test` passes; `cargo clippy` has no warnings</verify>
  <done>metadata.rs provides CRUD functions for both todo and project metadata with JSON validation and reserved key rejection</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for metadata operations</name>
  <files>src/storage/metadata.rs</files>
  <action>
    Add test module to metadata.rs:

    ```rust
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::storage::database::init_database;
        use std::env;
        use tempfile::TempDir;

        fn setup_test_env() -> TempDir {
            let temp_dir = TempDir::new().unwrap();
            env::set_var("HOME", temp_dir.path());
            init_database().unwrap();
            temp_dir
        }

        // Test cases:
        // 1. set_todo_metadata stores and get retrieves
        // 2. get_todo_metadata returns {} for non-existent
        // 3. set_todo_metadata with merge=true merges keys
        // 4. set_todo_metadata with merge=false replaces entirely
        // 5. Reserved key prefix _ is rejected
        // 6. Invalid JSON is rejected
        // 7. delete_todo_metadata returns true for existing, false for non-existent
        // 8. Similar tests for project_metadata
    }
    ```

    Include at least 6-8 focused tests covering the key behaviors.
  </action>
  <verify>`cargo test metadata` passes all tests</verify>
  <done>Comprehensive test coverage for metadata CRUD operations including edge cases</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `cargo build` - compiles without errors
2. `cargo test` - all tests pass
3. `cargo clippy` - no warnings
4. Manual inspection: init_database has metadata table creation
5. Manual inspection: metadata.rs has all 6 CRUD functions
</verification>

<success_criteria>
- Database schema includes todo_metadata and project_metadata tables with proper indexes
- CRUD operations work correctly (set, get, delete for both todos and projects)
- JSON validation rejects invalid JSON
- Reserved key prefix (_) is rejected with clear error message
- get_metadata returns {} for missing entries
- merge=true uses json_patch, merge=false replaces entirely
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-metadata-database/10-01-SUMMARY.md`
</output>
