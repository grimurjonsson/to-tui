---
phase: 10-metadata-database
plan: 03
type: execute
wave: 2
depends_on: ["10-01", "10-02"]
files_modified:
  - src/plugin/command_executor.rs
  - src/plugin/host_impl.rs
autonomous: true

must_haves:
  truths:
    - "Plugin can set todo metadata via FfiCommand and it persists to database"
    - "Plugin can query its own todo metadata via HostApi"
    - "Plugin can set project metadata via FfiCommand and it persists to database"
    - "Plugin can query its own project metadata via HostApi"
    - "Metadata operations integrate with undo/redo (single undo point for batch)"
  artifacts:
    - path: "src/plugin/command_executor.rs"
      provides: "Handles SetTodoMetadata, SetProjectMetadata, DeleteTodoMetadata, DeleteProjectMetadata commands"
      contains: "FfiCommand::SetTodoMetadata"
    - path: "src/plugin/host_impl.rs"
      provides: "Implements HostApi metadata query methods"
      contains: "fn get_todo_metadata"
  key_links:
    - from: "src/plugin/command_executor.rs"
      to: "src/storage/metadata.rs"
      via: "metadata CRUD calls"
      pattern: "storage::metadata::"
    - from: "src/plugin/host_impl.rs"
      to: "src/storage/metadata.rs"
      via: "metadata query calls"
      pattern: "storage::metadata::"
---

<objective>
Wire metadata operations through CommandExecutor and PluginHostApiImpl.

Purpose: Connect the FFI interface to the storage layer, completing the metadata pipeline. Plugins can now set and query metadata through the established patterns.

Output: CommandExecutor handles metadata FfiCommands, PluginHostApiImpl implements HostApi metadata methods.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-metadata-database/10-CONTEXT.md
@.planning/phases/10-metadata-database/10-RESEARCH.md
@.planning/phases/10-metadata-database/10-01-SUMMARY.md
@.planning/phases/10-metadata-database/10-02-SUMMARY.md

@src/plugin/command_executor.rs
@src/plugin/host_impl.rs
@src/storage/metadata.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Handle metadata commands in CommandExecutor</name>
  <files>src/plugin/command_executor.rs</files>
  <action>
    Extend `execute_batch` to handle the new metadata command variants.

    1. Add import at top:
       ```rust
       use crate::storage::metadata;
       ```

    2. In the match on `command` in `execute_batch`, add cases for the new variants:

       ```rust
       FfiCommand::SetTodoMetadata {
           todo_id,
           data,
           merge,
       } => {
           let uuid = self.resolve_id(todo_id.as_str())?;
           metadata::set_todo_metadata(&uuid, &self.plugin_name, data.as_str(), merge)?;
       }
       FfiCommand::SetProjectMetadata {
           project_name,
           data,
           merge,
       } => {
           metadata::set_project_metadata(
               project_name.as_str(),
               &self.plugin_name,
               data.as_str(),
               merge,
           )?;
       }
       FfiCommand::DeleteTodoMetadata { todo_id } => {
           let uuid = self.resolve_id(todo_id.as_str())?;
           metadata::delete_todo_metadata(&uuid, &self.plugin_name)?;
       }
       FfiCommand::DeleteProjectMetadata { project_name } => {
           metadata::delete_project_metadata(project_name.as_str(), &self.plugin_name)?;
       }
       ```

    3. Add `plugin_name: String` field to `CommandExecutor` struct.

    4. Update `new()` to take `plugin_name: String` parameter and store it.

    5. Update `Default` impl to use empty string for plugin_name (or remove Default impl and update call sites).

    Note: Metadata operations happen immediately (not batched in memory). They integrate with undo because the entire batch of commands (including todo mutations) is wrapped in a single undo snapshot by AppState.
  </action>
  <verify>`cargo build` compiles</verify>
  <done>CommandExecutor handles SetTodoMetadata, SetProjectMetadata, DeleteTodoMetadata, DeleteProjectMetadata commands</done>
</task>

<task type="auto">
  <name>Task 2: Implement HostApi metadata query methods in PluginHostApiImpl</name>
  <files>src/plugin/host_impl.rs</files>
  <action>
    Implement the metadata query methods in `PluginHostApiImpl`.

    1. Add import:
       ```rust
       use crate::storage::metadata;
       use totui_plugin_interface::FfiTodoMetadata;
       ```

    2. Implement `get_todo_metadata`:
       ```rust
       fn get_todo_metadata(&self, todo_id: RString) -> RString {
           let Ok(uuid) = Uuid::parse_str(&todo_id) else {
               return "{}".into();
           };
           metadata::get_todo_metadata(&uuid, &self.plugin_name)
               .unwrap_or_else(|_| "{}".to_string())
               .into()
       }
       ```

    3. Implement `get_todo_metadata_batch`:
       ```rust
       fn get_todo_metadata_batch(&self, todo_ids: RVec<RString>) -> RVec<FfiTodoMetadata> {
           let mut results = RVec::new();
           for id_str in todo_ids.iter() {
               let data = if let Ok(uuid) = Uuid::parse_str(id_str) {
                   metadata::get_todo_metadata(&uuid, &self.plugin_name)
                       .unwrap_or_else(|_| "{}".to_string())
               } else {
                   "{}".to_string()
               };
               results.push(FfiTodoMetadata {
                   todo_id: id_str.clone(),
                   data: data.into(),
               });
           }
           results
       }
       ```

    4. Implement `get_project_metadata`:
       ```rust
       fn get_project_metadata(&self, project_name: RString) -> RString {
           metadata::get_project_metadata(project_name.as_str(), &self.plugin_name)
               .unwrap_or_else(|_| "{}".to_string())
               .into()
       }
       ```

    5. Implement `query_todos_by_metadata`:
       ```rust
       fn query_todos_by_metadata(&self, key: RString, value: RString) -> RVec<FfiTodoItem> {
           // This requires a more complex query that joins todos with metadata.
           // For now, implement by filtering the current todo list.
           // Future: Add proper storage::metadata::query_todos_by_metadata function.

           let key_str = key.to_string();
           let value_str = value.to_string();
           let mut results = RVec::new();

           for (idx, item) in self.todo_list.items.iter().enumerate() {
               if item.deleted_at.is_some() {
                   continue;
               }
               // Get metadata for this item
               let metadata_json = metadata::get_todo_metadata(&item.id, &self.plugin_name)
                   .unwrap_or_else(|_| "{}".to_string());

               // Check if key matches value
               if let Ok(metadata) = serde_json::from_str::<serde_json::Value>(&metadata_json) {
                   if let Some(actual_value) = metadata.get(&key_str) {
                       // Compare as JSON values
                       if let Ok(expected) = serde_json::from_str::<serde_json::Value>(&value_str) {
                           if actual_value == &expected {
                               let mut ffi_item: FfiTodoItem = item.into();
                               ffi_item.position = idx as u32;
                               results.push(ffi_item);
                           }
                       }
                   }
               }
           }
           results
       }
       ```

    6. Implement `list_projects_with_metadata`:
       ```rust
       fn list_projects_with_metadata(&self) -> RVec<RString> {
           // For now, only check current project since we don't have access to all projects.
           // Future: Load from database with proper query.
           let mut results = RVec::new();

           if self.can_access_project(&self.current_project.name) {
               let metadata = metadata::get_project_metadata(
                   &self.current_project.name,
                   &self.plugin_name,
               ).unwrap_or_else(|_| "{}".to_string());

               // Only include if metadata exists (not empty {})
               if metadata != "{}" {
                   results.push(self.current_project.name.clone().into());
               }
           }
           results
       }
       ```
  </action>
  <verify>`cargo build` compiles</verify>
  <done>PluginHostApiImpl implements all HostApi metadata query methods</done>
</task>

<task type="auto">
  <name>Task 3: Update call sites and add integration tests</name>
  <files>src/plugin/command_executor.rs, src/app/state.rs</files>
  <action>
    1. Find all places where `CommandExecutor::new()` is called and update to pass plugin_name.

    2. In `src/app/state.rs`, update `execute_plugin_with_host` to pass the plugin name to CommandExecutor:
       ```rust
       let mut executor = CommandExecutor::new(plugin_name.to_string());
       ```

    3. Add integration tests to command_executor.rs for metadata commands:
       ```rust
       #[test]
       fn test_execute_set_todo_metadata() {
           // Setup with temp database
           // Create todo
           // Execute SetTodoMetadata command
           // Verify metadata was stored
       }

       #[test]
       fn test_execute_delete_todo_metadata() {
           // Setup with temp database
           // Create todo and set metadata
           // Execute DeleteTodoMetadata command
           // Verify metadata was deleted
       }
       ```

    4. If Default is used elsewhere and can't be changed, keep Default impl returning empty string for plugin_name (it's only used for tests).
  </action>
  <verify>`cargo test` passes; `cargo clippy` has no warnings</verify>
  <done>CommandExecutor properly receives plugin_name; integration tests verify end-to-end metadata flow</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `cargo build` - compiles without errors
2. `cargo test` - all tests pass including new metadata tests
3. `cargo clippy` - no warnings
4. Manual inspection: CommandExecutor handles all 4 metadata command variants
5. Manual inspection: PluginHostApiImpl implements all 5 metadata query methods
6. Verify: Metadata operations go through storage layer
</verification>

<success_criteria>
- CommandExecutor handles SetTodoMetadata, SetProjectMetadata, DeleteTodoMetadata, DeleteProjectMetadata
- PluginHostApiImpl implements get_todo_metadata, get_todo_metadata_batch, get_project_metadata, query_todos_by_metadata, list_projects_with_metadata
- plugin_name is properly threaded through for namespace isolation
- Integration tests verify metadata CRUD through the full pipeline
- All operations integrate with existing undo/redo (batch commands share single undo point)
</success_criteria>

<output>
After completion, create `.planning/phases/10-metadata-database/10-03-SUMMARY.md`
</output>
