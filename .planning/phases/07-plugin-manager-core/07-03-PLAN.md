---
phase: 07-plugin-manager-core
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - src/config.rs
  - src/cli.rs
  - src/main.rs
  - src/plugin/manager.rs
autonomous: true

must_haves:
  truths:
    - "totui plugin list shows all installed plugins with status"
    - "totui plugin enable <name> adds plugin to enabled state in config"
    - "totui plugin disable <name> removes plugin from enabled state in config"
    - "totui plugin status <name> shows detailed plugin information"
    - "Disabled plugins remain installed but are filtered from enabled_plugins()"
  artifacts:
    - path: "src/config.rs"
      provides: "PluginsConfig struct with enable/disable methods"
      contains: "pub struct PluginsConfig"
    - path: "src/cli.rs"
      provides: "PluginCommand enum with List/Enable/Disable/Status"
      contains: "pub enum PluginCommand"
    - path: "src/main.rs"
      provides: "handle_plugin_command() implementation"
      contains: "fn handle_plugin_command"
  key_links:
    - from: "src/main.rs"
      to: "src/plugin/manager.rs"
      via: "PluginManager::discover()"
      pattern: "PluginManager::discover"
    - from: "src/main.rs"
      to: "src/config.rs"
      via: "Config::load() and save()"
      pattern: "Config::load.*config\\.plugins"
    - from: "src/plugin/manager.rs"
      to: "src/config.rs"
      via: "apply_config() method"
      pattern: "fn apply_config"
---

<objective>
Add Config extension for plugin enable/disable state and CLI commands for plugin management.

Purpose: Complete the plugin management UX with persistent enable/disable and CLI interface.
Output: Working `totui plugin list|enable|disable|status` commands.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-plugin-manager-core/07-CONTEXT.md
@.planning/phases/07-plugin-manager-core/07-RESEARCH.md
@.planning/phases/07-plugin-manager-core/07-02-SUMMARY.md
@src/config.rs
@src/cli.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PluginsConfig to Config struct</name>
  <files>src/config.rs</files>
  <action>
Add PluginsConfig struct and integrate with Config:

```rust
use std::collections::HashSet;

/// Plugin enable/disable configuration
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct PluginsConfig {
    /// Explicitly disabled plugins (enabled by default)
    #[serde(default)]
    pub disabled: HashSet<String>,
}

impl PluginsConfig {
    /// Check if a plugin is enabled (not in disabled set)
    pub fn is_enabled(&self, name: &str) -> bool {
        !self.disabled.contains(&name.to_lowercase())
    }

    /// Enable a plugin by removing from disabled set
    pub fn enable(&mut self, name: &str) {
        self.disabled.remove(&name.to_lowercase());
    }

    /// Disable a plugin by adding to disabled set
    pub fn disable(&mut self, name: &str) {
        self.disabled.insert(name.to_lowercase());
    }
}
```

Add to Config struct:
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    // ... existing fields ...

    #[serde(default)]
    pub plugins: PluginsConfig,
}
```

Update Default impl to include `plugins: PluginsConfig::default()`.

Add tests:
```rust
#[test]
fn test_plugins_config_default_enabled() {
    let config = PluginsConfig::default();
    assert!(config.is_enabled("any-plugin"));
}

#[test]
fn test_plugins_config_disable_enable() {
    let mut config = PluginsConfig::default();
    config.disable("my-plugin");
    assert!(!config.is_enabled("my-plugin"));
    assert!(!config.is_enabled("MY-PLUGIN")); // case insensitive

    config.enable("MY-PLUGIN");
    assert!(config.is_enabled("my-plugin"));
}

#[test]
fn test_config_with_plugins_serialization_roundtrip() {
    // Verify Config with plugins field serializes/deserializes correctly
    let mut config = Config::default();
    config.plugins.disable("test-plugin");

    let toml_str = toml::to_string(&config).unwrap();
    assert!(toml_str.contains("[plugins]"));
    assert!(toml_str.contains("test-plugin"));

    let parsed: Config = toml::from_str(&toml_str).unwrap();
    assert!(!parsed.plugins.is_enabled("test-plugin"));
}
```
  </action>
  <verify>cargo test plugins_config passes && cargo test config_with_plugins passes</verify>
  <done>PluginsConfig struct exists with enable/disable methods and Config serialization round-trip verified</done>
</task>

<task type="auto">
  <name>Task 2: Add apply_config() to PluginManager</name>
  <files>src/plugin/manager.rs</files>
  <action>
Add method to apply config state to discovered plugins:

```rust
use crate::config::PluginsConfig;

impl PluginManager {
    /// Apply config to update enabled state of plugins
    pub fn apply_config(&mut self, config: &PluginsConfig) {
        for (name, info) in self.plugins.iter_mut() {
            info.enabled = config.is_enabled(name);
        }
    }
}
```

Add test:
```rust
#[test]
fn test_apply_config() {
    let mut manager = PluginManager::default();
    manager.plugins.insert("plugin-a".to_string(), PluginInfo {
        manifest: PluginManifest::default(),
        path: PathBuf::from("/a"),
        enabled: true,
        error: None,
    });
    manager.plugins.insert("plugin-b".to_string(), PluginInfo {
        manifest: PluginManifest::default(),
        path: PathBuf::from("/b"),
        enabled: true,
        error: None,
    });

    let mut plugins_config = PluginsConfig::default();
    plugins_config.disable("plugin-a");

    manager.apply_config(&plugins_config);

    assert!(!manager.get("plugin-a").unwrap().enabled);
    assert!(manager.get("plugin-b").unwrap().enabled);
}
```
  </action>
  <verify>cargo test apply_config passes</verify>
  <done>apply_config() method exists and correctly sets enabled state from config</done>
</task>

<task type="auto">
  <name>Task 3: Add plugin CLI subcommands and handlers</name>
  <files>src/cli.rs, src/main.rs</files>
  <action>
In src/cli.rs, add Plugin command variant and PluginCommand enum:

```rust
#[derive(Subcommand, Debug)]
pub enum Commands {
    // ... existing commands ...

    /// Manage plugins
    Plugin {
        #[command(subcommand)]
        command: PluginCommand,
    },
}

#[derive(Subcommand, Debug)]
pub enum PluginCommand {
    /// List installed plugins
    List,
    /// Enable a plugin
    Enable {
        /// Plugin name
        name: String,
    },
    /// Disable a plugin
    Disable {
        /// Plugin name
        name: String,
    },
    /// Show detailed plugin status
    Status {
        /// Plugin name
        name: String,
    },
}
```

In src/main.rs, add handler function and wire up in main:

```rust
use plugin::{PluginManager, PluginInfo};
use utils::paths::get_plugins_dir;

fn handle_plugin_command(command: PluginCommand) -> Result<()> {
    match command {
        PluginCommand::List => {
            let config = Config::load()?;
            let mut manager = PluginManager::discover()?;
            manager.apply_config(&config.plugins);

            println!("\nInstalled plugins:\n");

            let mut plugins: Vec<_> = manager.list().collect();
            plugins.sort_by(|a, b| a.manifest.name.cmp(&b.manifest.name));

            if plugins.is_empty() {
                println!("  (no plugins installed)");
                println!("\n  Plugins directory: {:?}", get_plugins_dir()?);
            } else {
                for info in plugins {
                    let status = if let Some(ref err) = info.error {
                        format!("\x1b[31m[error: {}]\x1b[0m", err)
                    } else if !info.available {
                        // Show availability issue (PLUG-06)
                        let reason = info.availability_reason.as_deref().unwrap_or("unavailable");
                        format!("\x1b[31m[unavailable: {}]\x1b[0m", reason)
                    } else if info.enabled {
                        "\x1b[32m[enabled]\x1b[0m".to_string()
                    } else {
                        "\x1b[33m[disabled]\x1b[0m".to_string()
                    };

                    println!("  {} v{} - {} {}",
                        info.manifest.name,
                        info.manifest.version,
                        info.manifest.description,
                        status);
                }
            }

            println!();
            Ok(())
        }
        PluginCommand::Enable { name } => {
            // Verify plugin exists
            let manager = PluginManager::discover()?;
            if manager.get(&name).is_none() {
                return Err(anyhow!("Plugin '{}' not found. Run 'totui plugin list' to see installed plugins.", name));
            }

            let mut config = Config::load()?;
            config.plugins.enable(&name);
            config.save()?;
            println!("Plugin '{}' enabled", name);
            Ok(())
        }
        PluginCommand::Disable { name } => {
            // Verify plugin exists
            let manager = PluginManager::discover()?;
            if manager.get(&name).is_none() {
                return Err(anyhow!("Plugin '{}' not found. Run 'totui plugin list' to see installed plugins.", name));
            }

            let mut config = Config::load()?;
            config.plugins.disable(&name);
            config.save()?;
            println!("Plugin '{}' disabled", name);
            Ok(())
        }
        PluginCommand::Status { name } => {
            let config = Config::load()?;
            let mut manager = PluginManager::discover()?;
            manager.apply_config(&config.plugins);

            match manager.get(&name) {
                Some(info) => {
                    println!("\nPlugin: {}", info.manifest.name);
                    println!("Version: {}", info.manifest.version);
                    println!("Description: {}", info.manifest.description);
                    println!("Path: {:?}", info.path);
                    println!("Enabled: {}", info.enabled);
                    println!("Available: {}", info.available);

                    if let Some(ref reason) = info.availability_reason {
                        println!("Availability: {}", reason);
                    }

                    if let Some(ref author) = info.manifest.author {
                        println!("Author: {}", author);
                    }
                    if let Some(ref license) = info.manifest.license {
                        println!("License: {}", license);
                    }
                    if let Some(ref homepage) = info.manifest.homepage {
                        println!("Homepage: {}", homepage);
                    }
                    if let Some(ref repository) = info.manifest.repository {
                        println!("Repository: {}", repository);
                    }
                    if let Some(ref min_ver) = info.manifest.min_interface_version {
                        println!("Min Interface Version: {}", min_ver);
                    }

                    if let Some(ref err) = info.error {
                        println!("\n\x1b[31mError: {}\x1b[0m", err);
                    }
                    println!();
                }
                None => {
                    println!("Plugin '{}' not found", name);
                    println!("Run 'totui plugin list' to see installed plugins");
                }
            }
            Ok(())
        }
    }
}
```

Wire up in main function's command match:
```rust
Some(Commands::Plugin { command }) => {
    handle_plugin_command(command)?;
}
```
  </action>
  <verify>cargo build --release && ./target/release/totui plugin list</verify>
  <done>All four plugin subcommands work: list, enable, disable, status</done>
</task>

</tasks>

<verification>
1. `cargo build --release` - builds successfully
2. `totui plugin list` - shows empty plugins message with directory path
3. `totui plugin enable test` - shows "not found" error (no plugins installed)
4. `totui plugin status test` - shows "not found" message
5. `cargo test plugins_config` - config tests pass
6. `cargo test apply_config` - manager tests pass
7. `cargo clippy` - no warnings
</verification>

<success_criteria>
- PluginsConfig struct with HashSet<String> for disabled plugins
- Config includes plugins field with serde default
- Config serialization round-trip preserves plugins configuration
- PluginManager.apply_config() updates enabled state from config
- All four CLI commands implemented: list, enable, disable, status
- Enable/disable verify plugin exists before modifying config
- Status shows all manifest fields, error, and availability status
- List shows unavailable plugins with reason (PLUG-06 dependency reporting)
- Case-insensitive plugin name handling throughout
</success_criteria>

<output>
After completion, create `.planning/phases/07-plugin-manager-core/07-03-SUMMARY.md`
</output>
