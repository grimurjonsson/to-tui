---
phase: 07-plugin-manager-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/plugin/manifest.rs
  - src/plugin/mod.rs
autonomous: true

must_haves:
  truths:
    - "Plugin with valid manifest is recognized by PluginManager (no error in PluginInfo)"
    - "Plugin with invalid manifest shows error in PluginInfo.error field"
    - "Plugin with extra/unknown TOML fields loads successfully (forward compatibility)"
  artifacts:
    - path: "src/plugin/manifest.rs"
      provides: "PluginManifest struct with serde deserialization"
      exports: ["PluginManifest"]
    - path: "src/plugin/mod.rs"
      provides: "Re-exports manifest module"
      contains: "pub mod manifest"
  key_links:
    - from: "src/plugin/manifest.rs"
      to: "semver::Version"
      via: "validate() method"
      pattern: "Version::parse"
---

<objective>
Define the PluginManifest struct for parsing plugin.toml files with validation.

Purpose: Establish the TOML schema for plugin manifests that Phase 7 discovery will use.
Output: PluginManifest struct with serde derives and validate() method.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-plugin-manager-core/07-CONTEXT.md
@.planning/phases/07-plugin-manager-core/07-RESEARCH.md
@src/config.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PluginManifest struct with serde derives</name>
  <files>src/plugin/manifest.rs, src/plugin/mod.rs</files>
  <action>
Create src/plugin/manifest.rs with PluginManifest struct:

Required fields:
- name: String
- version: String
- description: String

Optional fields (use #[serde(default)]):
- author: Option<String>
- license: Option<String>
- homepage: Option<String>
- repository: Option<String>
- min_interface_version: Option<String>

Add Default impl that returns placeholder values for name/version/description (needed for PluginInfo error cases).

Follow existing Config pattern from src/config.rs for serde usage.

Add `pub mod manifest;` to src/plugin/mod.rs.
  </action>
  <verify>cargo check compiles without errors</verify>
  <done>PluginManifest struct exists with all fields and serde derives</done>
</task>

<task type="auto">
  <name>Task 2: Add manifest validation with semver</name>
  <files>src/plugin/manifest.rs</files>
  <action>
Add validate() method to PluginManifest impl:

```rust
impl PluginManifest {
    pub fn validate(&self) -> Result<(), String> {
        // Name cannot be empty
        if self.name.is_empty() {
            return Err("Plugin name cannot be empty".to_string());
        }

        // Version must be valid semver
        if semver::Version::parse(&self.version).is_err() {
            return Err(format!("Invalid version '{}': must be valid semver", self.version));
        }

        // Description cannot be empty
        if self.description.is_empty() {
            return Err("Plugin description cannot be empty".to_string());
        }

        // min_interface_version must be valid semver if present
        if let Some(ref min_ver) = self.min_interface_version {
            if semver::Version::parse(min_ver).is_err() {
                return Err(format!("Invalid min_interface_version '{}'", min_ver));
            }
        }

        Ok(())
    }
}
```

Note: semver crate is already in workspace via totui-plugin-interface.
  </action>
  <verify>cargo check compiles without errors</verify>
  <done>validate() method exists and checks all required fields</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for manifest parsing and validation</name>
  <files>src/plugin/manifest.rs</files>
  <action>
Add tests module with:

1. test_parse_valid_manifest - parse complete valid TOML
2. test_parse_minimal_manifest - parse with only required fields
3. test_parse_with_unknown_fields - verify unknown fields are ignored
4. test_validate_empty_name - validate returns error
5. test_validate_invalid_version - validate returns error for "not-semver"
6. test_validate_empty_description - validate returns error
7. test_validate_invalid_min_interface_version - validate returns error for bad version

Use this pattern:
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_valid_manifest() {
        let toml = r#"
name = "my-plugin"
version = "1.0.0"
description = "A test plugin"
author = "Test Author"
"#;
        let manifest: PluginManifest = toml::from_str(toml).unwrap();
        assert_eq!(manifest.name, "my-plugin");
        assert!(manifest.validate().is_ok());
    }
}
```
  </action>
  <verify>cargo test manifest passes</verify>
  <done>All 7 tests pass for parsing and validation scenarios</done>
</task>

</tasks>

<verification>
1. `cargo check` - compiles without errors
2. `cargo test manifest` - all manifest tests pass
3. `cargo clippy` - no warnings
</verification>

<success_criteria>
- PluginManifest struct with Serialize, Deserialize, Debug, Clone derives
- validate() method checks name, version, description, min_interface_version
- Unknown TOML fields are silently ignored (serde default behavior)
- 7 unit tests cover parsing and validation edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/07-plugin-manager-core/07-01-SUMMARY.md`
</output>
