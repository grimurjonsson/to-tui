---
phase: 07-plugin-manager-core
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/plugin/manager.rs
  - src/plugin/mod.rs
  - src/utils/paths.rs
autonomous: true

must_haves:
  truths:
    - "PluginManager::discover() scans ~/.local/share/to-tui/plugins/ directory"
    - "Each plugin directory is read for plugin.toml manifest"
    - "Parse errors are captured in PluginInfo.error, not panicked"
    - "Missing plugins directory returns empty PluginManager (no crash)"
    - "Plugin with incompatible min_interface_version shows availability error (PLUG-06)"
  artifacts:
    - path: "src/plugin/manager.rs"
      provides: "PluginManager and PluginInfo structs"
      exports: ["PluginManager", "PluginInfo"]
    - path: "src/utils/paths.rs"
      provides: "get_plugins_dir() function"
      contains: "pub fn get_plugins_dir"
  key_links:
    - from: "src/plugin/manager.rs"
      to: "src/plugin/manifest.rs"
      via: "PluginManifest parsing"
      pattern: "toml::from_str.*PluginManifest"
    - from: "src/plugin/manager.rs"
      to: "src/utils/paths.rs"
      via: "get_plugins_dir()"
      pattern: "get_plugins_dir"
    - from: "src/plugin/manager.rs"
      to: "totui_plugin_interface"
      via: "is_version_compatible() for PLUG-06"
      pattern: "is_version_compatible"
---

<objective>
Create PluginManager that discovers plugins from disk and tracks their state.

Purpose: Provide plugin discovery and registration infrastructure for enable/disable and loading.
Output: PluginManager with discover(), list(), get(), enabled_plugins() methods.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-plugin-manager-core/07-CONTEXT.md
@.planning/phases/07-plugin-manager-core/07-RESEARCH.md
@.planning/phases/07-plugin-manager-core/07-01-SUMMARY.md
@src/plugin/manifest.rs
@src/utils/paths.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add get_plugins_dir() to paths utility</name>
  <files>src/utils/paths.rs</files>
  <action>
Add function to get plugins directory path:

```rust
/// Get the plugins directory path
/// Following CONTEXT.md: ~/.local/share/to-tui/plugins/
pub fn get_plugins_dir() -> Result<PathBuf> {
    let data_dir = dirs::data_local_dir()
        .ok_or_else(|| anyhow!("Could not find local data directory"))?;
    Ok(data_dir.join("to-tui").join("plugins"))
}
```

This follows the flat structure from CONTEXT.md: plugins/<plugin-name>/plugin.toml

Add a test:
```rust
#[test]
fn test_get_plugins_dir() {
    let dir = get_plugins_dir().unwrap();
    assert!(dir.to_string_lossy().contains("to-tui"));
    assert!(dir.to_string_lossy().ends_with("plugins"));
}
```
  </action>
  <verify>cargo test get_plugins_dir passes</verify>
  <done>get_plugins_dir() function returns ~/.local/share/to-tui/plugins/</done>
</task>

<task type="auto">
  <name>Task 2: Create PluginInfo and PluginManager structs</name>
  <files>src/plugin/manager.rs, src/plugin/mod.rs</files>
  <action>
Create src/plugin/manager.rs with:

```rust
use crate::plugin::manifest::PluginManifest;
use crate::utils::paths::get_plugins_dir;
use anyhow::{Context, Result};
use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};

/// Information about a discovered plugin
#[derive(Debug, Clone)]
pub struct PluginInfo {
    pub manifest: PluginManifest,
    pub path: PathBuf,
    pub enabled: bool,
    pub error: Option<String>,
}

/// Manages plugin discovery and state
#[derive(Debug, Default)]
pub struct PluginManager {
    plugins: HashMap<String, PluginInfo>,
}

impl PluginManager {
    /// Discover plugins from ~/.local/share/to-tui/plugins/
    pub fn discover() -> Result<Self> {
        let plugins_dir = get_plugins_dir()?;
        let mut manager = Self::default();

        if !plugins_dir.exists() {
            tracing::debug!("Plugins directory does not exist: {:?}", plugins_dir);
            return Ok(manager);
        }

        let entries = fs::read_dir(&plugins_dir)
            .with_context(|| format!("Failed to read plugins directory: {:?}", plugins_dir))?;

        for entry in entries {
            let entry = match entry {
                Ok(e) => e,
                Err(e) => {
                    tracing::warn!("Failed to read directory entry: {}", e);
                    continue;
                }
            };

            let plugin_dir = entry.path();
            if !plugin_dir.is_dir() {
                continue;
            }

            let name = match plugin_dir.file_name().and_then(|n| n.to_str()) {
                Some(n) => n.to_string(),
                None => continue,
            };

            let info = Self::load_plugin_info(&plugin_dir);
            tracing::debug!("Discovered plugin '{}': error={:?}", name, info.error);
            manager.plugins.insert(name.to_lowercase(), info);
        }

        Ok(manager)
    }

    fn load_plugin_info(plugin_dir: &Path) -> PluginInfo {
        let manifest_path = plugin_dir.join("plugin.toml");

        // Check manifest exists
        if !manifest_path.exists() {
            return PluginInfo {
                manifest: PluginManifest::default(),
                path: plugin_dir.to_path_buf(),
                enabled: true,
                error: Some("Missing plugin.toml".to_string()),
            };
        }

        // Read manifest file
        let content = match fs::read_to_string(&manifest_path) {
            Ok(c) => c,
            Err(e) => {
                return PluginInfo {
                    manifest: PluginManifest::default(),
                    path: plugin_dir.to_path_buf(),
                    enabled: true,
                    error: Some(format!("Failed to read plugin.toml: {}", e)),
                };
            }
        };

        // Parse manifest
        let manifest: PluginManifest = match toml::from_str(&content) {
            Ok(m) => m,
            Err(e) => {
                return PluginInfo {
                    manifest: PluginManifest::default(),
                    path: plugin_dir.to_path_buf(),
                    enabled: true,
                    error: Some(format!("Invalid plugin.toml: {}", e)),
                };
            }
        };

        // Validate manifest
        if let Err(e) = manifest.validate() {
            return PluginInfo {
                manifest,
                path: plugin_dir.to_path_buf(),
                enabled: true,
                error: Some(e),
            };
        }

        PluginInfo {
            manifest,
            path: plugin_dir.to_path_buf(),
            enabled: true,
            error: None,
        }
    }

    /// List all discovered plugins
    pub fn list(&self) -> Vec<&PluginInfo> {
        self.plugins.values().collect()
    }

    /// Get a plugin by name (case-insensitive)
    pub fn get(&self, name: &str) -> Option<&PluginInfo> {
        self.plugins.get(&name.to_lowercase())
    }

    /// Get mutable reference to a plugin by name (case-insensitive)
    pub fn get_mut(&mut self, name: &str) -> Option<&mut PluginInfo> {
        self.plugins.get_mut(&name.to_lowercase())
    }

    /// List plugins that are enabled and have no errors
    pub fn enabled_plugins(&self) -> Vec<&PluginInfo> {
        self.plugins
            .values()
            .filter(|p| p.enabled && p.error.is_none())
            .collect()
    }

    /// Get plugins with errors (for status bar warning)
    pub fn plugins_with_errors(&self) -> Vec<(&String, &PluginInfo)> {
        self.plugins
            .iter()
            .filter(|(_, p)| p.error.is_some())
            .collect()
    }
}
```

Add `pub mod manager;` to src/plugin/mod.rs and re-export:
```rust
pub use manager::{PluginInfo, PluginManager};
```
  </action>
  <verify>cargo test manager passes</verify>
  <done>PluginManager with discover(), list(), get(), enabled_plugins() methods exists and tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Add interface version compatibility check (PLUG-06)</name>
  <files>src/plugin/manager.rs</files>
  <action>
Add availability checking to PluginInfo that reports interface version compatibility:

1. Add `available: bool` field to PluginInfo struct (true if no errors and version compatible)
2. Add `availability_reason: Option<String>` field for detailed status

In `load_plugin_info()`, after successful manifest validation:
- Check if `min_interface_version` is specified in manifest
- If specified, use `totui_plugin_interface::is_version_compatible()` to check against host
- If incompatible, set `available = false` and `availability_reason = Some("Requires interface version X.Y.Z, host provides A.B.C")`
- If compatible or not specified, set `available = true`

Add to Cargo.toml dependency on totui-plugin-interface (if not already present) for accessing `INTERFACE_VERSION` constant.

```rust
// In load_plugin_info(), after manifest validation succeeds:
if let Some(ref min_ver) = manifest.min_interface_version {
    use totui_plugin_interface::{is_version_compatible, INTERFACE_VERSION};
    match is_version_compatible(min_ver, INTERFACE_VERSION) {
        Ok(true) => {
            // Compatible
        }
        Ok(false) => {
            return PluginInfo {
                manifest,
                path: plugin_dir.to_path_buf(),
                enabled: true,
                available: false,
                availability_reason: Some(format!(
                    "Requires interface version {}, host provides {}",
                    min_ver, INTERFACE_VERSION
                )),
                error: None,
            };
        }
        Err(e) => {
            return PluginInfo {
                manifest,
                path: plugin_dir.to_path_buf(),
                enabled: true,
                available: false,
                availability_reason: Some(format!("Version check failed: {}", e)),
                error: None,
            };
        }
    }
}
```

Update `enabled_plugins()` to filter by both `enabled` AND `available`:
```rust
pub fn enabled_plugins(&self) -> Vec<&PluginInfo> {
    self.plugins
        .values()
        .filter(|p| p.enabled && p.available && p.error.is_none())
        .collect()
}
```

Add `available_plugins()` method that shows all plugins that could be loaded (regardless of enabled state):
```rust
pub fn available_plugins(&self) -> Vec<&PluginInfo> {
    self.plugins
        .values()
        .filter(|p| p.available && p.error.is_none())
        .collect()
}
```
  </action>
  <verify>cargo test manager passes (includes new availability tests)</verify>
  <done>PluginInfo has available field and min_interface_version is checked against host version</done>
</task>

<task type="auto">
  <name>Task 4: Add unit tests for PluginManager</name>
  <files>src/plugin/manager.rs</files>
  <action>
Add tests module with tests for discovery, errors, and availability:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::TempDir;

    fn create_test_plugin(dir: &Path, name: &str, manifest_content: &str) {
        let plugin_dir = dir.join(name);
        fs::create_dir_all(&plugin_dir).unwrap();
        let manifest_path = plugin_dir.join("plugin.toml");
        let mut file = fs::File::create(manifest_path).unwrap();
        file.write_all(manifest_content.as_bytes()).unwrap();
    }

    #[test]
    fn test_load_valid_plugin() {
        let temp_dir = TempDir::new().unwrap();
        let manifest = r#"
name = "test-plugin"
version = "1.0.0"
description = "A test plugin"
"#;
        create_test_plugin(temp_dir.path(), "test-plugin", manifest);

        let info = PluginManager::load_plugin_info(&temp_dir.path().join("test-plugin"));
        assert!(info.error.is_none());
        assert!(info.available);
        assert_eq!(info.manifest.name, "test-plugin");
        assert!(info.enabled);
    }

    #[test]
    fn test_load_missing_manifest() {
        let temp_dir = TempDir::new().unwrap();
        let plugin_dir = temp_dir.path().join("no-manifest");
        fs::create_dir_all(&plugin_dir).unwrap();

        let info = PluginManager::load_plugin_info(&plugin_dir);
        assert!(info.error.is_some());
        assert!(!info.available);
        assert!(info.error.unwrap().contains("Missing plugin.toml"));
    }

    #[test]
    fn test_load_invalid_toml() {
        let temp_dir = TempDir::new().unwrap();
        create_test_plugin(temp_dir.path(), "bad-plugin", "this is not valid toml [[[");

        let info = PluginManager::load_plugin_info(&temp_dir.path().join("bad-plugin"));
        assert!(info.error.is_some());
        assert!(!info.available);
        assert!(info.error.unwrap().contains("Invalid plugin.toml"));
    }

    #[test]
    fn test_load_invalid_version() {
        let temp_dir = TempDir::new().unwrap();
        let manifest = r#"
name = "bad-version"
version = "not-semver"
description = "Has invalid version"
"#;
        create_test_plugin(temp_dir.path(), "bad-version", manifest);

        let info = PluginManager::load_plugin_info(&temp_dir.path().join("bad-version"));
        assert!(info.error.is_some());
        assert!(info.error.unwrap().contains("Invalid version"));
    }

    #[test]
    fn test_incompatible_min_interface_version() {
        // Test PLUG-06: plugin requiring higher interface version than host provides
        let temp_dir = TempDir::new().unwrap();
        let manifest = r#"
name = "future-plugin"
version = "1.0.0"
description = "Requires future interface"
min_interface_version = "99.0.0"
"#;
        create_test_plugin(temp_dir.path(), "future-plugin", manifest);

        let info = PluginManager::load_plugin_info(&temp_dir.path().join("future-plugin"));
        assert!(info.error.is_none()); // Not a parse error
        assert!(!info.available);      // But not available
        assert!(info.availability_reason.is_some());
        assert!(info.availability_reason.unwrap().contains("Requires interface version"));
    }

    #[test]
    fn test_compatible_min_interface_version() {
        // Plugin requiring current or older interface version should be available
        let temp_dir = TempDir::new().unwrap();
        let manifest = r#"
name = "compatible-plugin"
version = "1.0.0"
description = "Compatible interface"
min_interface_version = "0.1.0"
"#;
        create_test_plugin(temp_dir.path(), "compatible-plugin", manifest);

        let info = PluginManager::load_plugin_info(&temp_dir.path().join("compatible-plugin"));
        assert!(info.error.is_none());
        // Note: this may fail if host interface version < 0.1.0, adjust test accordingly
        // For now, assume host version >= 0.1.0
    }

    #[test]
    fn test_case_insensitive_lookup() {
        let mut manager = PluginManager::default();
        manager.plugins.insert("my-plugin".to_string(), PluginInfo {
            manifest: PluginManifest::default(),
            path: PathBuf::from("/test"),
            enabled: true,
            available: true,
            availability_reason: None,
            error: None,
        });

        assert!(manager.get("my-plugin").is_some());
        assert!(manager.get("MY-PLUGIN").is_some());
        assert!(manager.get("My-Plugin").is_some());
    }

    #[test]
    fn test_enabled_plugins_filters_errors_and_unavailable() {
        let mut manager = PluginManager::default();

        manager.plugins.insert("good".to_string(), PluginInfo {
            manifest: PluginManifest::default(),
            path: PathBuf::from("/good"),
            enabled: true,
            available: true,
            availability_reason: None,
            error: None,
        });

        manager.plugins.insert("errored".to_string(), PluginInfo {
            manifest: PluginManifest::default(),
            path: PathBuf::from("/errored"),
            enabled: true,
            available: false,
            availability_reason: None,
            error: Some("Some error".to_string()),
        });

        manager.plugins.insert("unavailable".to_string(), PluginInfo {
            manifest: PluginManifest::default(),
            path: PathBuf::from("/unavailable"),
            enabled: true,
            available: false,
            availability_reason: Some("Version mismatch".to_string()),
            error: None,
        });

        manager.plugins.insert("disabled".to_string(), PluginInfo {
            manifest: PluginManifest::default(),
            path: PathBuf::from("/disabled"),
            enabled: false,
            available: true,
            availability_reason: None,
            error: None,
        });

        let enabled = manager.enabled_plugins();
        assert_eq!(enabled.len(), 1);
        assert_eq!(enabled[0].path, PathBuf::from("/good"));
    }
}
```

Note: Add `tempfile = "3"` to dev-dependencies in Cargo.toml if not present.
  </action>
  <verify>cargo test manager passes</verify>
  <done>All 9 unit tests for PluginManager pass including availability tests</done>
</task>

</tasks>

<verification>
1. `cargo check` - compiles without errors
2. `cargo test manager` - all manager tests pass
3. `cargo test get_plugins_dir` - path test passes
4. `cargo clippy` - no warnings
</verification>

<success_criteria>
- get_plugins_dir() returns ~/.local/share/to-tui/plugins/ path
- PluginManager::discover() scans plugins directory
- Missing directory returns empty manager (no crash)
- Invalid manifests captured in PluginInfo.error
- Case-insensitive plugin name lookup works
- enabled_plugins() filters out disabled, errored, and unavailable plugins
- min_interface_version checked against host INTERFACE_VERSION (PLUG-06)
- Incompatible plugins have available=false with availability_reason
</success_criteria>

<output>
After completion, create `.planning/phases/07-plugin-manager-core/07-02-SUMMARY.md`
</output>
