---
phase: 12-keybinding-integration
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/config.rs
  - src/keybindings/mod.rs
  - src/app/state.rs
  - src/app/event.rs
  - src/ui/components/mod.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "User can override plugin keybindings in config.toml"
    - "Key events route to plugins after host handling"
    - "Plugin actions appear in help panel grouped by plugin"
    - "Plugin action execution shows status message and handles errors"
  artifacts:
    - path: "src/config.rs"
      provides: "Keybindings plugins section parsing"
      contains: "plugins: HashMap<String, HashMap<String, String>>"
    - path: "src/app/state.rs"
      provides: "PluginActionRegistry field in AppState"
      contains: "plugin_action_registry"
    - path: "src/app/event.rs"
      provides: "Plugin action routing in handle_navigate_mode"
      contains: "plugin_action_registry.lookup"
  key_links:
    - from: "src/app/event.rs"
      to: "src/plugin/actions.rs"
      via: "PluginActionRegistry lookup in KeyLookupResult::None branch"
      pattern: "plugin_action_registry.*lookup"
    - from: "src/ui/components/mod.rs"
      to: "src/plugin/actions.rs"
      via: "actions_by_plugin for help panel"
      pattern: "actions_by_plugin"
---

<objective>
Integrate plugin actions into the TUI: config parsing for user overrides, key event routing to plugins, help panel display, and action execution with feedback.

Purpose: Complete the keybinding integration so users can trigger plugin actions via keybindings and discover them in the help panel.

Output: Full integration of plugin actions into the TUI experience.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-keybinding-integration/12-CONTEXT.md
@.planning/phases/12-keybinding-integration/12-RESEARCH.md
@.planning/phases/12-keybinding-integration/12-01-SUMMARY.md
@src/config.rs
@src/keybindings/mod.rs
@src/app/state.rs
@src/app/event.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend config with plugin keybinding overrides</name>
  <files>src/config.rs, src/keybindings/mod.rs</files>
  <action>
Extend KeybindingsConfig to support plugin keybinding overrides:

In src/keybindings/mod.rs, add to KeybindingsConfig:
```rust
/// Plugin keybinding overrides.
/// Structure: plugins.{plugin_name}.{action_name} = "keybinding"
/// Example: plugins.jira.fetch = "<C-j>"
/// Set to "" or "none" to disable an action
#[serde(default)]
pub plugins: HashMap<String, HashMap<String, String>>,
```

Update Default impl for KeybindingsConfig:
```rust
impl Default for KeybindingsConfig {
    fn default() -> Self {
        Self {
            navigate: default_navigate_bindings(),
            edit: default_edit_bindings(),
            visual: default_visual_bindings(),
            plugins: HashMap::new(),
        }
    }
}
```

Update merge_with_defaults to handle plugins:
```rust
pub fn merge_with_defaults(mut self) -> Self {
    let defaults = Self::default();

    for (key, value) in defaults.navigate {
        self.navigate.entry(key).or_insert(value);
    }
    for (key, value) in defaults.edit {
        self.edit.entry(key).or_insert(value);
    }
    for (key, value) in defaults.visual {
        self.visual.entry(key).or_insert(value);
    }
    // plugins has no defaults - user overrides only

    self
}
```

Add import at top: `use std::collections::HashMap;` (should already exist)

Add test for parsing config with plugin keybindings:
```rust
#[test]
fn test_plugin_keybindings_config() {
    let toml_str = r#"
[keybindings.plugins.jira]
fetch = "<C-j>"
sync = "none"

[keybindings.plugins.github]
pr = "<C-g>"
"#;
    let config: KeybindingsConfig = toml::from_str(toml_str).unwrap();
    assert_eq!(config.plugins.get("jira").unwrap().get("fetch").unwrap(), "<C-j>");
    assert_eq!(config.plugins.get("jira").unwrap().get("sync").unwrap(), "none");
    assert_eq!(config.plugins.get("github").unwrap().get("pr").unwrap(), "<C-g>");
}
```
  </action>
  <verify>cargo test --lib keybindings -- --nocapture</verify>
  <done>KeybindingsConfig parses [keybindings.plugins.{name}] sections</done>
</task>

<task type="auto">
  <name>Task 2: Add PluginActionRegistry to AppState and wire initialization</name>
  <files>src/app/state.rs, src/main.rs</files>
  <action>
Add PluginActionRegistry to AppState:

Import at top of src/app/state.rs:
```rust
use crate::plugin::{PluginActionRegistry, PluginAction, PluginManager};
```

Add field to AppState struct:
```rust
/// Registry of plugin actions with keybinding mappings
pub plugin_action_registry: PluginActionRegistry,
```

Add parameter to AppState::new() for plugin_action_registry:
```rust
pub fn new(
    todo_list: TodoList,
    theme: Theme,
    keybindings: KeybindingCache,
    timeoutlen: u64,
    plugin_registry: PluginRegistry,
    ui_cache: Option<UiCache>,
    skipped_version: Option<String>,
    current_project: Project,
    plugin_loader: PluginLoader,
    plugin_errors: Vec<PluginLoadError>,
    plugin_action_registry: PluginActionRegistry,  // NEW PARAMETER
) -> Self {
```

Initialize field in the Self struct:
```rust
plugin_action_registry,
```

The registry must be built OUTSIDE of AppState::new() because it requires:
1. KeybindingsConfig (consumed to build KeybindingCache)
2. PluginManager (for manifest info)
3. KeybindingCache (for conflict detection)

In main.rs (or wherever AppState is constructed), build the registry BEFORE creating AppState:
```rust
// Build plugin action registry from loaded plugins
let plugin_action_registry = {
    let mut registry = PluginActionRegistry::new();

    // Get plugin keybinding overrides from config
    let plugin_overrides = &keybindings_config.plugins;

    // Register actions from plugin manager's discovered plugins
    for plugin_info in plugin_manager.plugins() {
        if !plugin_info.enabled || !plugin_info.available {
            continue;
        }

        let overrides = plugin_overrides
            .get(&plugin_info.manifest.name)
            .cloned()
            .unwrap_or_default();

        let warnings = registry.register_plugin(
            &plugin_info.manifest,
            &overrides,
            &keybinding_cache,
        );

        for warning in warnings {
            tracing::warn!("{}", warning);
        }
    }

    registry
};

// Then pass to AppState::new()
let state = AppState::new(
    // ... other params ...
    plugin_action_registry,
);
```

Note: This approach avoids storing KeybindingsConfig in AppState by building the registry during initialization when all required data is available.
  </action>
  <verify>cargo build --lib</verify>
  <done>AppState has plugin_action_registry field, initialized via parameter from main.rs</done>
</task>

<task type="auto">
  <name>Task 3: Route key events to plugin actions</name>
  <files>src/app/event.rs</files>
  <action>
Modify handle_navigate_mode() to check plugin actions when host keybinding lookup returns None.

In the match block for state.keybindings.lookup_navigate():

```rust
match state.keybindings.lookup_navigate(&key, pending) {
    KeyLookupResult::Pending => {
        state.pending_key = Some(KeyBinding::from_event(&key));
        state.pending_key_time = Some(std::time::Instant::now());
        return Ok(());
    }
    KeyLookupResult::Action(action) => {
        execute_navigate_action(action, state)?;
    }
    KeyLookupResult::None => {
        // Check plugin actions
        let binding = KeyBinding::from_event(&key);
        if let Some(plugin_action) = state.plugin_action_registry.lookup(&binding) {
            execute_plugin_action(plugin_action.clone(), state)?;
        }
    }
}
```

Add import at top:
```rust
use crate::plugin::{PluginAction, CommandExecutor, PluginHostApiImpl, PluginLoadError, PluginErrorKind};
use totui_plugin_interface::{call_plugin_execute_with_host, HostApi_TO};
use abi_stable::sabi_trait::TD_Opaque;
use abi_stable::std_types::RBox;
use std::collections::HashSet;
```

Add execute_plugin_action function. NOTE: Use the existing pattern from AppState::execute_plugin_with_host() but adapted for PluginAction:

```rust
fn execute_plugin_action(action: PluginAction, state: &mut AppState) -> Result<()> {
    // Show status message while running
    state.set_status_message(format!("Running {}...", action.action_name));

    // Find the loaded plugin
    let loaded_plugin = state.plugin_loader
        .loaded_plugins()
        .find(|p| p.name == action.plugin_name);

    let loaded_plugin = match loaded_plugin {
        Some(p) => p,
        None => {
            state.pending_plugin_errors.push(PluginLoadError {
                plugin_name: action.plugin_name.clone(),
                error_kind: PluginErrorKind::Other("Plugin not loaded".to_string()),
                message: format!("Plugin '{}' is not loaded", action.plugin_name),
            });
            state.show_plugin_error_popup = true;
            return Ok(());
        }
    };

    // Build enabled projects set (for now, just current project)
    let mut enabled_projects = HashSet::new();
    enabled_projects.insert(state.current_project.name.clone());

    // Create HostApi implementation (same pattern as AppState::execute_plugin_with_host)
    let host_api = PluginHostApiImpl::new(
        &state.todo_list,
        &state.current_project,
        enabled_projects,
        action.plugin_name.clone(),
    );

    // Convert to FFI-safe trait object
    let host_to: HostApi_TO<'_, RBox<()>> = HostApi_TO::from_value(host_api, TD_Opaque);

    // Execute plugin action (blocking)
    // The plugin's execute_with_host receives action name as input string
    // Use call_plugin_execute_with_host from totui_plugin_interface (panic-safe wrapper)
    let result = call_plugin_execute_with_host(
        &loaded_plugin.plugin,
        action.action_name.as_str().into(),
        host_to,
    );

    match result.into_result() {
        Ok(commands) => {
            if !commands.is_empty() {
                state.save_undo();
                let mut executor = CommandExecutor::new(action.plugin_name.clone());
                let commands_vec: Vec<_> = commands.into_iter().collect();
                if let Err(e) = executor.execute_batch(commands_vec, &mut state.todo_list) {
                    state.set_status_message(format!("Error: {}", e));
                } else {
                    state.unsaved_changes = true;
                    state.set_status_message(format!("{} complete", action.action_name));
                }
            } else {
                state.set_status_message(format!("{} complete", action.action_name));
            }
        }
        Err(e) => {
            // Show error in popup
            state.pending_plugin_errors.push(PluginLoadError {
                plugin_name: action.plugin_name.clone(),
                error_kind: PluginErrorKind::Other(e.to_string()),
                message: e.to_string(),
            });
            state.show_plugin_error_popup = true;
        }
    }

    Ok(())
}
```

Key implementation notes:
1. Use `totui_plugin_interface::call_plugin_execute_with_host` (NOT crate::plugin::loader::*)
2. Use `abi_stable::sabi_trait::TD_Opaque` (NOT type_erase::TD_Opaque)
3. PluginHostApiImpl::new takes 4 args: (&TodoList, &Project, HashSet<String>, String)
4. This matches the existing pattern in AppState::execute_plugin_with_host (line 1033-1084)
  </action>
  <verify>cargo build --lib</verify>
  <done>Key events route to plugin actions when host keybinding returns None</done>
</task>

<task type="auto">
  <name>Task 4: Add plugin actions to help panel</name>
  <files>src/ui/components/mod.rs</files>
  <action>
Extend render_help_overlay() to include plugin actions section.

Find the function render_help_overlay (search for "fn render_help_overlay" or similar).

After the existing help sections (Edit Mode section), add:

```rust
// Plugin Actions section (only if any enabled plugins have actions)
let actions_by_plugin = state.plugin_action_registry.actions_by_plugin();
if !actions_by_plugin.is_empty() {
    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled(
        "  ── Plugin Actions ──",
        Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD),
    )));

    // Sort plugin names for consistent display
    let mut plugin_names: Vec<_> = actions_by_plugin.keys().collect();
    plugin_names.sort();

    for plugin_name in plugin_names {
        let actions = &actions_by_plugin[plugin_name];

        lines.push(Line::from(vec![
            Span::styled(
                format!("  [{}]", plugin_name),
                Style::default().fg(Color::Blue).add_modifier(Modifier::BOLD),
            ),
        ]));

        for action in actions {
            // NOTE: PluginAction.keybinding is Option<KeyBinding>
            // KeyBinding implements Display (see keybindings/mod.rs line 241-282)
            // Format the KeyBinding directly using its Display impl
            let key_text = action
                .keybinding
                .as_ref()
                .map(|kb| format!("{:<16}", kb))  // KeyBinding has Display impl
                .unwrap_or_else(|| "(no binding)    ".to_string());

            lines.push(Line::from(vec![
                Span::styled(format!("    {}  ", key_text), key_style),
                Span::styled(&action.description, desc_style),
            ]));
        }
    }
}
```

Implementation notes:
1. `KeyBinding` implements `Display` (defined at line 241 in keybindings/mod.rs)
2. `KeySequence` does NOT implement `Display` - but that's OK because PluginAction stores a single `KeyBinding`, not a `KeySequence`
3. Use `format!("{:<16}", kb)` for left-aligned padding (not `format!("{:16}", k)`)
4. The `key_style` and `desc_style` should match existing help panel styles. Look at how other sections are styled and match that pattern.

Update HELP_TOTAL_LINES constant in src/app/event.rs if it's hardcoded. The help overlay should handle dynamic height based on content. If it's fixed, consider making it dynamic or increasing the count to accommodate potential plugin sections.
  </action>
  <verify>cargo build --lib</verify>
  <done>Plugin actions appear in help panel grouped by plugin name</done>
</task>

</tasks>

<verification>
```bash
# Build succeeds
cargo build --lib

# All tests pass
cargo test --lib

# Clippy clean
cargo clippy --lib -- -D warnings

# Manual verification:
# 1. Create a test plugin with actions in manifest
# 2. Add [keybindings.plugins.test] override in config.toml
# 3. Run TUI and press ? to see help - plugin actions should appear
# 4. Press the plugin keybinding - action should execute
```
</verification>

<success_criteria>
1. Config parses [keybindings.plugins.{name}.{action}] sections
2. AppState has plugin_action_registry populated from loaded plugins
3. Pressing unbound host key checks plugin registry and executes matching action
4. Plugin actions show in help panel under "Plugin Actions" section
5. Action execution shows status message, handles errors via existing popup
6. All tests pass and clippy is clean
</success_criteria>

<output>
After completion, create `.planning/phases/12-keybinding-integration/12-02-SUMMARY.md`
</output>
