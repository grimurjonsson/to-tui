---
phase: 11-plugin-configuration
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/plugin/loader.rs
  - src/cli.rs
  - src/main.rs
  - src/app/state.rs
autonomous: true

must_haves:
  truths:
    - "Plugin config is validated during load_all() before plugin is added to loader"
    - "Config errors appear in existing plugin error popup on TUI startup"
    - "CLI command 'totui plugin validate <name>' checks config without starting TUI"
    - "CLI command 'totui plugin config <name> --init' creates config directory and template"
  artifacts:
    - path: "src/plugin/loader.rs"
      provides: "Config-aware plugin loading"
      contains: "load_all_with_config"
    - path: "src/cli.rs"
      provides: "Plugin validate and config CLI commands"
      contains: "Validate"
    - path: "src/main.rs"
      provides: "CLI handlers and TUI config error integration"
      contains: "handle_plugin_validate"
  key_links:
    - from: "src/plugin/loader.rs"
      to: "src/plugin/config.rs"
      via: "PluginConfigLoader::load_and_validate"
      pattern: "PluginConfigLoader::load_and_validate"
    - from: "src/main.rs"
      to: "src/ui/components/mod.rs"
      via: "ConfigError in pending_plugin_errors"
      pattern: "ConfigError"
---

<objective>
Integrate config loading into plugin lifecycle and add CLI commands for validation and template generation.

Purpose: Connect the config types and loader from Plan 01 to the actual plugin loading flow, surface config errors in the TUI, and provide CLI tooling for users to validate and bootstrap config files.

Output: Config validation during plugin load, config errors in error popup, and two new CLI commands.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-plugin-configuration/11-CONTEXT.md
@.planning/phases/11-plugin-configuration/11-RESEARCH.md
@.planning/phases/11-plugin-configuration/11-01-SUMMARY.md
@src/plugin/loader.rs
@src/plugin/config.rs
@src/cli.rs
@src/main.rs
@src/app/state.rs
@src/ui/components/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate config loading into PluginLoader</name>
  <files>src/plugin/loader.rs</files>
  <action>
Extend PluginLoader to validate config during plugin loading:

1. Add ConfigError struct (similar to PluginLoadError):
   ```rust
   pub struct ConfigError {
       pub plugin_name: String,
       pub message: String,
   }
   ```
   Implement Display and Error traits.

2. Add new method load_all_with_config():
   ```rust
   pub fn load_all_with_config(
       &mut self,
       manager: &PluginManager,
   ) -> (Vec<PluginLoadError>, Vec<ConfigError>)
   ```
   For each enabled plugin:
   - Call load_plugin() to load the dylib
   - If load succeeds, get schema via plugin.config_schema()
   - Call PluginConfigLoader::load_and_validate() with schema
   - If config valid, convert to FFI with to_ffi_config() and call plugin.on_config_loaded()
   - If config invalid, add to config_errors and don't add plugin to loaded map
   - Return both load errors and config errors separately

3. Update existing load_all() to call load_all_with_config() and return only load errors (for backward compatibility), but also store config errors. Add a method get_config_errors() -> &[ConfigError] to retrieve them after loading.

Import from src/plugin/config: PluginConfigLoader, to_ffi_config
Import call_plugin_on_config_loaded from totui_plugin_interface

Add tests:
- test_config_error_display
- test_config_error_is_error
  </action>
  <verify>cargo test --lib loader && cargo clippy -- -D warnings</verify>
  <done>PluginLoader validates config during load and collects ConfigError for failed validations</done>
</task>

<task type="auto">
  <name>Task 2: Add CLI commands for validate and config --init</name>
  <files>src/cli.rs, src/main.rs, src/plugin/config.rs</files>
  <action>
Add two new subcommands to PluginCommand enum in src/cli.rs:

```rust
/// Validate a plugin's configuration
Validate {
    /// Plugin name
    name: String,
},
/// Show or initialize plugin config
Config {
    /// Plugin name
    name: String,
    /// Generate template config from schema
    #[arg(long)]
    init: bool,
},
```

Add generate_config_template() function to src/plugin/config.rs:
- Takes &FfiConfigSchema, returns String
- For each field:
  - Add description as comment if present
  - Add type and required/optional as comment
  - For required fields: add `field = example_value`
  - For optional fields: add `# field = default_or_example`
- Return the template string

Add handler functions in src/main.rs:

1. handle_plugin_validate(name: &str) -> Result<()>
   - Discover plugins via PluginManager
   - Find plugin by name (case-insensitive)
   - Load the plugin to get schema
   - Call PluginConfigLoader::load_and_validate()
   - Print success or error message
   - Exit with code 1 on error

2. handle_plugin_config(name: &str, init: bool) -> Result<()>
   - If init:
     - Discover plugins, find by name, load to get schema
     - Create config directory with std::fs::create_dir_all()
     - Generate template via generate_config_template()
     - Write to config.toml
     - Print success message with path
   - If not init:
     - Show current config path and whether it exists
     - If exists, print schema summary (field names and types)

Wire up the new commands in match arms in main.rs handle_plugin_command().

Add tests for generate_config_template() in src/plugin/config.rs:
- test_generate_template_required_fields
- test_generate_template_optional_with_defaults
- test_generate_template_with_descriptions
  </action>
  <verify>cargo build && cargo test --lib config && cargo clippy -- -D warnings</verify>
  <done>CLI commands `totui plugin validate <name>` and `totui plugin config <name> --init` work</done>
</task>

<task type="auto">
  <name>Task 3: Surface config errors in TUI error popup</name>
  <files>src/main.rs, src/app/state.rs</files>
  <action>
Update TUI startup to show config errors alongside load errors:

1. In src/main.rs where TUI starts:
   - Change from load_all() to load_all_with_config() to get both error types
   - Convert ConfigError to PluginLoadError for display (config errors can reuse same popup):
     ```rust
     let config_as_load_errors: Vec<PluginLoadError> = config_errors.into_iter().map(|ce| {
         PluginLoadError {
             plugin_name: ce.plugin_name,
             error_kind: PluginErrorKind::Other(format!("Config: {}", ce.message)),
             message: ce.message,
         }
     }).collect();
     plugin_errors.extend(config_as_load_errors);
     ```
   - Pass combined errors to AppState

2. Update logging to distinguish config errors:
   - Log config errors with tracing::warn! using "config" context

3. In src/app/state.rs, update the test that checks plugin error handling to include a config error case (test_dismiss_plugin_error_popup or add new test).

The existing render_plugin_error_popup in src/ui/components/mod.rs needs no changes - it already shows plugin_name and message for any PluginLoadError.

Add integration test verifying config errors appear in pending_plugin_errors.
  </action>
  <verify>cargo test --lib && cargo build && cargo clippy -- -D warnings</verify>
  <done>Config errors display in TUI error popup on startup alongside load errors</done>
</task>

</tasks>

<verification>
After all tasks:
1. `cargo build` - Application compiles
2. `cargo test --lib` - All tests pass
3. `cargo clippy -- -D warnings` - No warnings
4. Manual test: `totui plugin validate nonexistent` exits with error
5. Manual test: `totui plugin config <name> --init` creates directory and template (if a plugin exists)
</verification>

<success_criteria>
- load_all_with_config() validates config and returns ConfigError for failures
- Invalid config prevents plugin from loading (not added to plugins map)
- Config errors appear in TUI error popup at startup
- `totui plugin validate <name>` validates config file against schema
- `totui plugin config <name> --init` creates config directory and template
- All tests pass and no clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/11-plugin-configuration/11-02-SUMMARY.md`
</output>
