---
phase: 09-host-api-layer
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/plugin/host_impl.rs
  - src/plugin/mod.rs
  - src/plugin/ffi_convert.rs
autonomous: true

must_haves:
  truths:
    - "PluginHostApiImpl implements HostApi trait"
    - "Query methods filter by plugin-enabled projects"
    - "Tree structure correctly nests children under parents"
    - "Position field populated in query results"
  artifacts:
    - path: "src/plugin/host_impl.rs"
      provides: "PluginHostApiImpl struct implementing HostApi"
      exports: ["PluginHostApiImpl"]
    - path: "src/plugin/mod.rs"
      provides: "Re-exports host_impl module"
      contains: "pub mod host_impl"
    - path: "src/plugin/ffi_convert.rs"
      provides: "FfiProjectContext conversion"
      contains: "impl From<&Project>"
  key_links:
    - from: "src/plugin/host_impl.rs"
      to: "totui_plugin_interface::HostApi"
      via: "impl HostApi for PluginHostApiImpl"
      pattern: "impl HostApi for"
    - from: "src/plugin/host_impl.rs"
      to: "src/todo/list.rs"
      via: "reads from TodoList"
      pattern: "todo_list\\.items"
---

<objective>
Implement the PluginHostApiImpl struct that provides query capabilities to plugins.

Purpose: Allow plugins to query current todos, get project context, and traverse the todo hierarchy.
Output: PluginHostApiImpl in src/plugin/host_impl.rs that wraps TodoList and provides filtered, position-aware query results.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-host-api-layer/09-RESEARCH.md
@.planning/phases/09-host-api-layer/09-CONTEXT.md
@.planning/phases/09-host-api-layer/09-01-SUMMARY.md
@src/plugin/ffi_convert.rs
@src/todo/list.rs
@src/project/registry.rs
@crates/totui-plugin-interface/src/host_api.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PluginHostApiImpl struct with query methods</name>
  <files>src/plugin/host_impl.rs</files>
  <action>
Create new file `src/plugin/host_impl.rs`:

1. **Imports:**
   - `use abi_stable::std_types::{ROption, RString, RVec};`
   - `use std::collections::HashSet;`
   - `use totui_plugin_interface::{FfiProjectContext, FfiStateFilter, FfiTodoItem, FfiTodoNode, FfiTodoQuery, HostApi};`
   - `use crate::project::Project;`
   - `use crate::todo::TodoList;`

2. **PluginHostApiImpl struct:**
```rust
/// Host API implementation that provides query access to plugins.
///
/// This struct holds immutable references to the current state,
/// allowing plugins to query todos and projects safely.
pub struct PluginHostApiImpl<'a> {
    /// The current todo list
    pub todo_list: &'a TodoList,
    /// The current project
    pub current_project: &'a Project,
    /// All projects where this plugin is enabled
    pub enabled_projects: HashSet<String>,
    /// Name of the plugin using this API (for access checks)
    pub plugin_name: String,
}
```

3. **impl PluginHostApiImpl:**
   - Constructor: `pub fn new(todo_list: &'a TodoList, current_project: &'a Project, enabled_projects: HashSet<String>, plugin_name: String) -> Self`

4. **impl HostApi for PluginHostApiImpl:**

   **current_project():**
   - Return `FfiProjectContext` from `self.current_project` using conversion

   **list_projects():**
   - Return `RVec<FfiProjectContext>` for all projects in `self.enabled_projects`
   - Note: For now, return only current project since full project list requires loading from DB
   - Future: Pass project registry reference for full list

   **query_todos(query: FfiTodoQuery):**
   - Check project access: if `query.project` specified and not in `enabled_projects`, return empty
   - If `query.project` is None or matches current project, filter `self.todo_list.items`
   - Apply filters:
     - `include_deleted`: skip items with `deleted_at.is_some()` unless true
     - `state_filter`: match FfiStateFilter::Done/Pending/All
     - `parent_id`: filter by parent UUID match
     - `date_from`/`date_to`: filter by item's `created_at` (convert to NaiveDate)
   - Map items to `FfiTodoItem` with position set to enumerate index
   - Return as `RVec<FfiTodoItem>`

   **get_todo(id: RString):**
   - Parse UUID from id string
   - Find item in `todo_list.items` where `item.id == uuid`
   - Return `ROption::RSome(item.into())` or `ROption::RNone`

   **query_todos_tree():**
   - Build tree structure from flat list
   - Helper function to collect children recursively
   - Return `RVec<FfiTodoNode>` with root items (indent_level == 0)
  </action>
  <verify>`cargo check` compiles without errors</verify>
  <done>PluginHostApiImpl exists with all HostApi methods implemented</done>
</task>

<task type="auto">
  <name>Task 2: Add FfiProjectContext conversion and wire module</name>
  <files>src/plugin/ffi_convert.rs, src/plugin/mod.rs</files>
  <action>
1. In `src/plugin/ffi_convert.rs`, add conversion for Project -> FfiProjectContext:
```rust
use totui_plugin_interface::FfiProjectContext;
use crate::project::Project;

impl From<&Project> for FfiProjectContext {
    fn from(project: &Project) -> Self {
        FfiProjectContext {
            id: project.id.to_string().into(),
            name: project.name.clone().into(),
            created_at: project.created_at.timestamp_millis(),
        }
    }
}
```

2. In `src/plugin/ffi_convert.rs`, update the `FfiTodoItem` conversion to set `position: 0` (will be overwritten by query methods):
   - In `impl From<&TodoItem> for FfiTodoItem`, add `position: 0,` to the struct initialization

3. In `src/plugin/mod.rs`:
   - Add `pub mod host_impl;`
   - Add `pub use host_impl::PluginHostApiImpl;` to re-exports
  </action>
  <verify>`cargo check` compiles. `cargo test -p totui` passes for ffi_convert tests.</verify>
  <done>FfiProjectContext conversion exists, host_impl module wired up</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for PluginHostApiImpl</name>
  <files>src/plugin/host_impl.rs</files>
  <action>
Add `#[cfg(test)]` module at the end of `host_impl.rs`:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::todo::{TodoItem, TodoList, TodoState};
    use chrono::Local;
    use std::path::PathBuf;

    fn create_test_list() -> TodoList {
        let date = Local::now().date_naive();
        let mut list = TodoList {
            date,
            items: vec![],
            file_path: PathBuf::from("/tmp/test.md"),
        };

        // Add root item
        let mut root = TodoItem::new("Root".to_string(), 0);
        let root_id = root.id;
        list.items.push(root);

        // Add child
        let mut child = TodoItem::new("Child".to_string(), 1);
        child.parent_id = Some(root_id);
        list.items.push(child);

        list
    }

    #[test]
    fn test_current_project() {
        let list = create_test_list();
        let project = Project::default_project();
        let api = PluginHostApiImpl::new(
            &list,
            &project,
            HashSet::from(["default".to_string()]),
            "test-plugin".to_string(),
        );

        let ctx = api.current_project();
        assert_eq!(ctx.name.to_string(), "default");
    }

    #[test]
    fn test_query_todos_returns_items_with_position() {
        let list = create_test_list();
        let project = Project::default_project();
        let api = PluginHostApiImpl::new(
            &list,
            &project,
            HashSet::from(["default".to_string()]),
            "test-plugin".to_string(),
        );

        let query = FfiTodoQuery::default();
        let results = api.query_todos(query);

        assert_eq!(results.len(), 2);
        assert_eq!(results[0].position, 0);
        assert_eq!(results[1].position, 1);
    }

    #[test]
    fn test_query_todos_tree_nests_children() {
        let list = create_test_list();
        let project = Project::default_project();
        let api = PluginHostApiImpl::new(
            &list,
            &project,
            HashSet::from(["default".to_string()]),
            "test-plugin".to_string(),
        );

        let tree = api.query_todos_tree();

        // Should have 1 root node
        assert_eq!(tree.len(), 1);
        // Root should have 1 child
        assert_eq!(tree[0].children.len(), 1);
    }

    #[test]
    fn test_get_todo_found() {
        let list = create_test_list();
        let project = Project::default_project();
        let first_id = list.items[0].id.to_string();
        let api = PluginHostApiImpl::new(
            &list,
            &project,
            HashSet::from(["default".to_string()]),
            "test-plugin".to_string(),
        );

        let result = api.get_todo(first_id.into());
        assert!(result.is_some());
    }

    #[test]
    fn test_get_todo_not_found() {
        let list = create_test_list();
        let project = Project::default_project();
        let api = PluginHostApiImpl::new(
            &list,
            &project,
            HashSet::from(["default".to_string()]),
            "test-plugin".to_string(),
        );

        let result = api.get_todo("00000000-0000-0000-0000-000000000000".into());
        assert!(result.is_none());
    }
}
```
  </action>
  <verify>`cargo test host_impl` passes all tests</verify>
  <done>Unit tests cover current_project, query_todos, query_todos_tree, get_todo</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check` - entire workspace compiles
2. `cargo test` - all tests pass including new host_impl tests
3. `cargo clippy` - no warnings
4. Verify HostApi implementation: `grep -r "impl HostApi for" src/plugin/` shows implementation
</verification>

<success_criteria>
- PluginHostApiImpl struct exists with all HostApi trait methods
- Query results include position field
- Tree structure correctly nests children
- Unit tests pass for all query operations
- FfiProjectContext conversion from Project works
</success_criteria>

<output>
After completion, create `.planning/phases/09-host-api-layer/09-02-SUMMARY.md`
</output>
