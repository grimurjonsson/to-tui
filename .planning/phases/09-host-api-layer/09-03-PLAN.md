---
phase: 09-host-api-layer
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/plugin/command_executor.rs
  - src/plugin/mod.rs
  - crates/totui-plugin-interface/src/plugin.rs
autonomous: true

must_haves:
  truths:
    - "CommandExecutor executes FfiCommand batch with single undo snapshot"
    - "Temp ID mapping resolves parent references within batch"
    - "Plugin trait has execute_with_host method"
    - "Invalid UUIDs return NotFound error"
  artifacts:
    - path: "src/plugin/command_executor.rs"
      provides: "CommandExecutor with execute_batch method"
      exports: ["CommandExecutor"]
    - path: "src/plugin/mod.rs"
      provides: "Re-exports command_executor module"
      contains: "pub mod command_executor"
    - path: "crates/totui-plugin-interface/src/plugin.rs"
      provides: "Extended Plugin trait with execute_with_host"
      contains: "fn execute_with_host"
  key_links:
    - from: "src/plugin/command_executor.rs"
      to: "src/app/state.rs"
      via: "calls save_undo() for atomic undo"
      pattern: "save_undo"
    - from: "src/plugin/command_executor.rs"
      to: "src/todo/list.rs"
      via: "mutates todo_list.items"
      pattern: "todo_list\\.items"
---

<objective>
Implement the CommandExecutor that processes plugin mutation commands with undo/redo integration.

Purpose: Enable plugins to mutate todos (create, update, delete, move) while preserving the application's undo/redo functionality with atomic batch operations.
Output: CommandExecutor in src/plugin/command_executor.rs, extended Plugin trait with execute_with_host method.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-host-api-layer/09-RESEARCH.md
@.planning/phases/09-host-api-layer/09-CONTEXT.md
@.planning/phases/09-host-api-layer/09-01-SUMMARY.md
@src/app/state.rs
@src/todo/list.rs
@src/todo/item.rs
@crates/totui-plugin-interface/src/plugin.rs
@crates/totui-plugin-interface/src/host_api.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CommandExecutor with execute_batch</name>
  <files>src/plugin/command_executor.rs</files>
  <action>
Create new file `src/plugin/command_executor.rs`:

1. **Imports:**
   - `use anyhow::{anyhow, Result};`
   - `use chrono::Utc;`
   - `use std::collections::HashMap;`
   - `use uuid::Uuid;`
   - `use totui_plugin_interface::{FfiCommand, FfiMovePosition, FfiTodoState, FfiPriority};`
   - `use crate::todo::{TodoItem, TodoList, TodoState, Priority};`

2. **CommandExecutor struct:**
```rust
/// Executes plugin commands with undo/redo integration.
///
/// Commands are executed as a batch with a single undo snapshot,
/// enabling atomic rollback of all plugin mutations.
pub struct CommandExecutor {
    /// Mapping from temp IDs to real UUIDs created during batch
    temp_id_map: HashMap<String, Uuid>,
}
```

3. **impl CommandExecutor:**

   **new():** Create with empty temp_id_map

   **execute_batch(&mut self, commands: Vec<FfiCommand>, todo_list: &mut TodoList) -> Result<Vec<Uuid>>:**
   - Clear temp_id_map at start
   - Track created_ids: Vec<Uuid>
   - For each command, call appropriate handler:
     - CreateTodo -> handle_create()
     - UpdateTodo -> handle_update()
     - DeleteTodo -> handle_delete()
     - MoveTodo -> handle_move()
   - After all commands: `todo_list.recalculate_parent_ids()`
   - Return created_ids

   **handle_create(&mut self, cmd: CreateTodo fields, todo_list: &mut TodoList) -> Result<Uuid>:**
   - Create new TodoItem with content, state, priority, indent_level
   - Generate UUID via Uuid::new_v4()
   - If temp_id provided, store mapping in temp_id_map
   - Resolve parent_id:
     - Check temp_id_map first for temp references
     - Then try Uuid::parse_str for real UUIDs
   - Set parent_id and insert at appropriate position:
     - If parent exists, find last child position and insert after
     - Otherwise append to end
   - Return the new UUID

   **handle_update(&mut self, cmd: UpdateTodo fields, todo_list: &mut TodoList) -> Result<()>:**
   - Resolve ID (check temp_id_map, then parse as UUID)
   - Find item in todo_list.items by UUID
   - Return `Err(anyhow!("Todo not found: {}", id))` if not found (per CONTEXT.md decision)
   - Update fields that are RSome:
     - content
     - state (convert FfiTodoState -> TodoState)
     - priority (convert FfiPriority -> Priority)
     - due_date (parse YYYY-MM-DD)
     - description
   - Set modified_at = Utc::now()

   **handle_delete(&mut self, cmd: DeleteTodo fields, todo_list: &mut TodoList) -> Result<()>:**
   - Resolve ID
   - Find item by UUID
   - Return error if not found
   - Set deleted_at = Some(Utc::now()) (soft delete per codebase convention)

   **handle_move(&mut self, cmd: MoveTodo fields, todo_list: &mut TodoList) -> Result<()>:**
   - Resolve ID
   - Find current index in items
   - Return error if not found
   - Remove item from current position
   - Based on FfiMovePosition:
     - Before { target_id }: Find target index, insert before
     - After { target_id }: Find target index, insert after
     - AtIndex { index }: Insert at index (clamped to bounds)

   **resolve_id(&self, id: &str) -> Result<Uuid>:**
   - Check temp_id_map first
   - Then try Uuid::parse_str
   - Return error if neither works
  </action>
  <verify>`cargo check` compiles without errors</verify>
  <done>CommandExecutor with execute_batch and all command handlers exists</done>
</task>

<task type="auto">
  <name>Task 2: Extend Plugin trait with execute_with_host method</name>
  <files>crates/totui-plugin-interface/src/plugin.rs</files>
  <action>
In `crates/totui-plugin-interface/src/plugin.rs`:

1. Add imports at top:
   - `use crate::host_api::{FfiCommand, HostApi_TO};`

2. Update the Plugin trait to add execute_with_host method:
   - Move `#[sabi(last_prefix_field)]` from `generate` to the new method
   - Add new method after `generate`:

```rust
    /// Generate todos from the given input.
    /// [existing docstring...]
    fn generate(&self, input: RString) -> RResult<RVec<FfiTodoItem>, RString>;

    /// Execute plugin logic with host API access.
    ///
    /// This method receives the host API for querying current state
    /// and returns a list of commands to be executed atomically.
    ///
    /// # Arguments
    ///
    /// * `input` - Plugin-specific input string
    /// * `host` - Host API trait object for querying todos and projects
    ///
    /// # Returns
    ///
    /// * `RResult::ROk(commands)` - List of commands to execute
    /// * `RResult::RErr(msg)` - Error message
    #[sabi(last_prefix_field)]
    fn execute_with_host(
        &self,
        input: RString,
        host: HostApi_TO<'_, RBox<()>>,
    ) -> RResult<RVec<FfiCommand>, RString>;
```

Note: Existing plugins implementing only `generate()` remain compatible.
New plugins can implement `execute_with_host()` for full CRUD capabilities.

3. Add a helper function similar to call_plugin_generate for the new method:
```rust
/// Wrapper for calling plugin.execute_with_host() safely.
pub fn call_plugin_execute_with_host(
    plugin: &Plugin_TO<'_, RBox<()>>,
    input: RString,
    host: HostApi_TO<'_, RBox<()>>,
) -> RResult<RVec<FfiCommand>, RString> {
    let result = catch_unwind(AssertUnwindSafe(|| plugin.execute_with_host(input, host)));

    match result {
        Ok(r) => r,
        Err(panic_info) => {
            let msg = if let Some(s) = panic_info.downcast_ref::<&str>() {
                format!("Plugin panicked: {}", s)
            } else if let Some(s) = panic_info.downcast_ref::<String>() {
                format!("Plugin panicked: {}", s)
            } else {
                "Plugin panicked with unknown error".to_string()
            };
            RResult::RErr(msg.into())
        }
    }
}
```
  </action>
  <verify>`cargo check -p totui-plugin-interface` compiles without errors</verify>
  <done>Plugin trait has execute_with_host method with HostApi_TO parameter</done>
</task>

<task type="auto">
  <name>Task 3: Wire module and add unit tests</name>
  <files>src/plugin/mod.rs, src/plugin/command_executor.rs, crates/totui-plugin-interface/src/lib.rs</files>
  <action>
1. In `src/plugin/mod.rs`:
   - Add `pub mod command_executor;`
   - Add `pub use command_executor::CommandExecutor;` to re-exports

2. In `crates/totui-plugin-interface/src/lib.rs`:
   - Add `call_plugin_execute_with_host` to re-exports from plugin module

3. Add tests in `src/plugin/command_executor.rs`:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use abi_stable::std_types::{ROption, RString};
    use chrono::Local;
    use std::path::PathBuf;
    use totui_plugin_interface::FfiTodoState;

    fn create_test_list() -> TodoList {
        let date = Local::now().date_naive();
        TodoList {
            date,
            items: vec![TodoItem::new("Existing".to_string(), 0)],
            file_path: PathBuf::from("/tmp/test.md"),
        }
    }

    #[test]
    fn test_execute_create_todo() {
        let mut list = create_test_list();
        let mut executor = CommandExecutor::new();

        let commands = vec![FfiCommand::CreateTodo {
            content: "New task".into(),
            parent_id: ROption::RNone,
            temp_id: ROption::RNone,
            state: FfiTodoState::Empty,
            priority: ROption::RNone,
            indent_level: 0,
        }];

        let created = executor.execute_batch(commands, &mut list).unwrap();

        assert_eq!(created.len(), 1);
        assert_eq!(list.items.len(), 2);
        assert_eq!(list.items[1].content, "New task");
    }

    #[test]
    fn test_execute_update_todo() {
        let mut list = create_test_list();
        let id = list.items[0].id.to_string();
        let mut executor = CommandExecutor::new();

        let commands = vec![FfiCommand::UpdateTodo {
            id: id.into(),
            content: ROption::RSome("Updated".into()),
            state: ROption::RNone,
            priority: ROption::RNone,
            due_date: ROption::RNone,
            description: ROption::RNone,
        }];

        executor.execute_batch(commands, &mut list).unwrap();

        assert_eq!(list.items[0].content, "Updated");
    }

    #[test]
    fn test_execute_delete_todo() {
        let mut list = create_test_list();
        let id = list.items[0].id.to_string();
        let mut executor = CommandExecutor::new();

        let commands = vec![FfiCommand::DeleteTodo { id: id.into() }];

        executor.execute_batch(commands, &mut list).unwrap();

        assert!(list.items[0].deleted_at.is_some());
    }

    #[test]
    fn test_temp_id_mapping() {
        let mut list = create_test_list();
        let mut executor = CommandExecutor::new();

        // Create parent with temp_id, then child referencing it
        let commands = vec![
            FfiCommand::CreateTodo {
                content: "Parent".into(),
                parent_id: ROption::RNone,
                temp_id: ROption::RSome("temp-1".into()),
                state: FfiTodoState::Empty,
                priority: ROption::RNone,
                indent_level: 0,
            },
            FfiCommand::CreateTodo {
                content: "Child".into(),
                parent_id: ROption::RSome("temp-1".into()),
                temp_id: ROption::RNone,
                state: FfiTodoState::Empty,
                priority: ROption::RNone,
                indent_level: 1,
            },
        ];

        let created = executor.execute_batch(commands, &mut list).unwrap();

        assert_eq!(created.len(), 2);
        // Child should reference parent
        let child = list.items.iter().find(|i| i.content == "Child").unwrap();
        assert_eq!(child.parent_id, Some(created[0]));
    }

    #[test]
    fn test_update_not_found_returns_error() {
        let mut list = create_test_list();
        let mut executor = CommandExecutor::new();

        let commands = vec![FfiCommand::UpdateTodo {
            id: "00000000-0000-0000-0000-000000000000".into(),
            content: ROption::RSome("Updated".into()),
            state: ROption::RNone,
            priority: ROption::RNone,
            due_date: ROption::RNone,
            description: ROption::RNone,
        }];

        let result = executor.execute_batch(commands, &mut list);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("not found"));
    }
}
```
  </action>
  <verify>`cargo test command_executor` passes all tests. `cargo test` passes entire suite.</verify>
  <done>CommandExecutor module wired up, unit tests pass for create, update, delete, temp_id mapping, error handling</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo check` - entire workspace compiles
2. `cargo test` - all tests pass including new command_executor tests
3. `cargo clippy` - no warnings
4. Verify execute_with_host exists: `grep "execute_with_host" crates/totui-plugin-interface/src/plugin.rs`
</verification>

<success_criteria>
- CommandExecutor.execute_batch() processes Create, Update, Delete, Move commands
- Temp ID mapping works for parent references within batch
- Invalid UUID returns NotFound error (not silent)
- Plugin trait extended with execute_with_host method
- All unit tests pass
- Soft delete uses deleted_at timestamp (not hard delete)
</success_criteria>

<output>
After completion, create `.planning/phases/09-host-api-layer/09-03-SUMMARY.md`
</output>
