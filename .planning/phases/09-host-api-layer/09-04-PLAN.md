---
phase: 09-host-api-layer
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/state.rs
  - src/plugin/command_executor.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Plugin can perform CRUD operations via PluginHostApi"
    - "All plugin mutations integrate with existing undo/redo system"
    - "Plugin execution creates undo snapshot before mutations"
  artifacts:
    - path: "src/app/state.rs"
      provides: "execute_plugin_with_host method"
      contains: "execute_plugin_with_host"
    - path: "src/plugin/command_executor.rs"
      provides: "CommandExecutor unchanged but wired"
  key_links:
    - from: "src/app/state.rs"
      to: "src/plugin/command_executor.rs"
      via: "CommandExecutor::execute_batch"
      pattern: "CommandExecutor"
    - from: "src/app/state.rs"
      to: "src/plugin/host_impl.rs"
      via: "PluginHostApiImpl::new"
      pattern: "PluginHostApiImpl"
    - from: "src/app/state.rs"
      to: "save_undo method"
      via: "self.save_undo()"
      pattern: "save_undo\\(\\)"
---

<objective>
Close gaps from Phase 9 verification: Wire CommandExecutor into AppState with undo integration.

**Gaps being addressed:**
1. **Undo/redo integration missing:** CommandExecutor.execute_batch() does NOT call save_undo(). No integration with AppState's undo history.
2. **Calling convention missing:** No method in AppState to invoke plugin with HostApi and process returned commands.

**Architecture decision:** The calling convention belongs in AppState (not CommandExecutor) because:
- AppState owns `save_undo()` and `undo_stack`
- AppState owns `todo_list` (mutable reference needed)
- AppState owns `plugin_loader` (access to plugins)
- AppState owns `current_project` (for PluginHostApiImpl)

This plan does NOT modify CommandExecutor's execute_batch() to call save_undo() because:
- CommandExecutor doesn't have access to AppState's undo_stack
- The caller (AppState) is responsible for undo snapshots
- This matches existing patterns (toggle_current_item_state calls save_undo before mutating)

Output: New `execute_plugin_with_host` method in AppState that creates undo snapshot, constructs HostApi, calls plugin, and executes returned commands.
</objective>

<execution_context>
@/Users/gimmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gimmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-host-api-layer/09-VERIFICATION.md
@.planning/phases/09-host-api-layer/09-02-SUMMARY.md
@.planning/phases/09-host-api-layer/09-03-SUMMARY.md

# Key existing code references
@src/app/state.rs
@src/plugin/command_executor.rs
@src/plugin/host_impl.rs
@crates/totui-plugin-interface/src/plugin.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add execute_plugin_with_host method to AppState</name>
  <files>src/app/state.rs</files>
  <action>
Add a new method `execute_plugin_with_host` to AppState that implements the full calling convention:

1. Add required imports at the top of the file:
   ```rust
   use crate::plugin::{CommandExecutor, PluginHostApiImpl};
   use totui_plugin_interface::{call_plugin_execute_with_host, HostApi_TO};
   use abi_stable::std_types::RBox;
   use std::collections::HashSet;
   ```

2. Add the method to the `impl AppState` block (after `execute_move_to_project` method around line 1009):

   ```rust
   /// Execute a loaded plugin with Host API access.
   ///
   /// This is the main calling convention for plugins that use execute_with_host.
   /// It:
   /// 1. Creates an undo snapshot BEFORE any mutations
   /// 2. Constructs PluginHostApiImpl with current state
   /// 3. Calls the plugin's execute_with_host method
   /// 4. Processes returned FfiCommands through CommandExecutor
   ///
   /// # Arguments
   /// * `plugin_name` - Name of the loaded plugin to execute
   /// * `input` - Input string to pass to the plugin
   ///
   /// # Returns
   /// * `Ok(count)` - Number of commands executed
   /// * `Err(e)` - If plugin not found, plugin returns error, or command execution fails
   pub fn execute_plugin_with_host(&mut self, plugin_name: &str, input: &str) -> Result<usize> {
       // Find the plugin
       let plugin = self.plugin_loader
           .loaded_plugins()
           .find(|p| p.name().to_string() == plugin_name)
           .ok_or_else(|| anyhow::anyhow!("Plugin not found: {}", plugin_name))?;

       // Build enabled projects set (for now, just current project)
       let mut enabled_projects = HashSet::new();
       enabled_projects.insert(self.current_project.name.clone());

       // Create HostApi implementation
       let host_api = PluginHostApiImpl::new(
           &self.todo_list,
           &self.current_project,
           enabled_projects,
           plugin_name.to_string(),
       );

       // Convert to FFI-safe trait object
       let host_to: HostApi_TO<'_, RBox<()>> = HostApi_TO::from_value(host_api, abi_stable::type_erase::TD_Opaque);

       // Call plugin (panic-safe wrapper)
       let result = call_plugin_execute_with_host(
           plugin,
           input.into(),
           host_to,
       );

       // Check for plugin errors
       let commands = match result.into_result() {
           Ok(cmds) => cmds,
           Err(e) => return Err(anyhow::anyhow!("Plugin error: {}", e)),
       };

       // If no commands, nothing to do
       if commands.is_empty() {
           return Ok(0);
       }

       // Save undo BEFORE mutations
       self.save_undo();

       // Execute commands
       let mut executor = CommandExecutor::new();
       let commands_vec: Vec<_> = commands.into_iter().collect();
       let command_count = commands_vec.len();

       executor.execute_batch(commands_vec, &mut self.todo_list)?;

       // Mark as modified
       self.unsaved_changes = true;

       Ok(command_count)
   }
   ```

3. Important notes:
   - `save_undo()` is called AFTER checking for empty commands (optimization)
   - `save_undo()` is called BEFORE `execute_batch` (ensures undo captures pre-mutation state)
   - Error handling: Plugin errors and command execution errors both return Err
   - The method takes plugin_name as parameter (not the Plugin_TO directly) because:
     - It avoids lifetime issues with the borrowed plugin reference
     - Matches the pattern used elsewhere (plugin selection by name)

4. Do NOT call this method from anywhere yet - Phase 10 will wire the P key to use this.
  </action>
  <verify>
1. Run `cargo check` - should compile without errors
2. Run `cargo clippy` - should pass with no warnings
3. Verify the new method exists: `grep -n "execute_plugin_with_host" src/app/state.rs`
4. Verify save_undo is called: `grep -A5 "Save undo BEFORE" src/app/state.rs`
  </verify>
  <done>AppState has execute_plugin_with_host method that creates undo snapshot before executing plugin commands</done>
</task>

<task type="auto">
  <name>Task 2: Add unit test for execute_plugin_with_host</name>
  <files>src/app/state.rs</files>
  <action>
Add a test to verify the calling convention works correctly. Add this test to the existing `#[cfg(test)] mod tests` block in state.rs:

```rust
#[test]
fn test_execute_plugin_with_host_not_found() {
    use crate::keybindings::KeybindingCache;
    use crate::plugin::{PluginLoader, PluginRegistry};
    use crate::todo::TodoList;
    use crate::ui::theme::Theme;
    use chrono::Local;

    let date = Local::now().date_naive();
    let todo_list = TodoList {
        date,
        items: vec![],
        file_path: std::path::PathBuf::from("/tmp/test.md"),
    };

    let mut state = AppState::new(
        todo_list,
        Theme::default(),
        KeybindingCache::default(),
        1000,
        PluginRegistry::new(),
        None,
        None,
        Project::default_project(),
        PluginLoader::new(),
        vec![],
    );

    // Try to execute non-existent plugin
    let result = state.execute_plugin_with_host("non-existent-plugin", "test input");

    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Plugin not found"));
}
```

This test verifies:
1. The method exists and is callable
2. Error handling for missing plugins works correctly
3. The method signature is correct

Note: A full integration test with a real plugin would require loading a .dylib, which is beyond the scope of this gap closure. The key verification is that the code path exists and compiles correctly.
  </action>
  <verify>
1. Run `cargo test test_execute_plugin_with_host_not_found` - should pass
2. Run full test suite: `cargo test` - all tests should pass
  </verify>
  <done>Unit test verifies execute_plugin_with_host exists and handles missing plugin correctly</done>
</task>

</tasks>

<verification>
Run these commands to verify the gap closure:

1. **Compilation check:**
   ```bash
   cargo check
   ```

2. **Lint check:**
   ```bash
   cargo clippy
   ```

3. **Test suite:**
   ```bash
   cargo test
   ```

4. **Verify key links exist:**
   ```bash
   # Method exists
   grep -n "pub fn execute_plugin_with_host" src/app/state.rs

   # Uses CommandExecutor
   grep -n "CommandExecutor" src/app/state.rs

   # Uses PluginHostApiImpl
   grep -n "PluginHostApiImpl" src/app/state.rs

   # Calls save_undo before execute_batch
   grep -B2 "execute_batch" src/app/state.rs | grep "save_undo"
   ```

5. **Verify imports:**
   ```bash
   grep "use crate::plugin::" src/app/state.rs | head -3
   ```
</verification>

<success_criteria>
- [ ] `cargo check` passes
- [ ] `cargo clippy` passes with no warnings
- [ ] `cargo test` passes (all 188+ tests)
- [ ] `execute_plugin_with_host` method exists in AppState
- [ ] Method calls `save_undo()` before `execute_batch()`
- [ ] Method uses `CommandExecutor` from `src/plugin/command_executor.rs`
- [ ] Method uses `PluginHostApiImpl` from `src/plugin/host_impl.rs`
- [ ] Test for missing plugin error handling passes
</success_criteria>

<output>
After completion, create `.planning/phases/09-host-api-layer/09-04-SUMMARY.md`
</output>
